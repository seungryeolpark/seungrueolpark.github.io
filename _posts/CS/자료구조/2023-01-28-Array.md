---
title: Array
categories: cs-ds
---

[1. Array](#Array)  
[2. Linked List](#Linked-List)  
[3. Array, Linked List, ArrayList](#Array-Linked-List-ArrayList)

## Array
+ 가장 기본적인 자료구조로 구현이 쉽다.
+ 논리적 저장 순서와 물리적 저장 순서가 일치하다.
    + 찾고자 하는 원소의 인덱스 값을 알고 있으면 시간복잡도 O(1) 에 해당 원소로 접근할 수 있다.
    + [Random Access](#Random-Access) 이다.
+ 배열의 원소를 삭제하거나 배열 원소 사이에 삽입할 경우 그 원소 순서 뒤에 있는 원소들은 shift 를 해야하기 때문에 시간복잡도 O(n) 이 된다. 

### Random Access
+ 집합 내의 요소의 주소를 알고 있다면 요소의 개수와 무관하게 모든 요소에 대하여 쉽고 효율적으로 동일한 시간에 접근할 수 있는 방식

## Linked List
+ 논리적 저장 순서와 물리적 저장 순서가 일치하지 않는다.
    + 첫번째 원소부터 원하는 원소를 찾기까지 순차적으로 확인해야 하기에 시간복잡도 O(n) 이 된다.
    + [Sequential Access](#Sequential-Access) 이다.
+ 배열의 원소를 추가하거나 삭제할시 앞에 있는 원소만 다음 연결할 주소를 다시 지정하면 되기에 시간 복잡도 O(1) 이 된다.

### Sequential Access
+ 순서가 정해진 원소 그룹을 순차적으로 접근하는 방식

## Array, Linked List, ArrayList
### Array
+ 장점
    + 인덱스를 통한 검색이 용이함
    + 연속적이므로 메모리 관리가 편하다.
+ 단점
    + 정적이므로 배열의 크기를 컴파일 이전에 정해줘야 한다.
    + 크기가 고정되어 메모리 낭비가 있다.
    + 삽입, 삭제 성능이 좋지 않다.

### Linked List
+ 장점 
    + 포인터를 통하여 다음 데이터 위치를 가르키고 있어 삽입 삭제 용이
    + 동적이므로 크기가 정해져 있지 않다.
    + 불연속적이므로 메모리 관리와 재사용이 편리하다.
+ 단점
    + 검색 성능이 좋지 않다.
    + 포인터를 통해 다음 데이터를 가르키므로 추가적인 메모리 공간 발생

### ArrayList
+ Array 처럼 크기를 정해주지 않아도 된다.
  + 더 이상 저장할 공간이 없으면 더 큰 배열을 새로 생성해 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장
+ Array 처럼 검색은 용이하지만 삽입과 삭제는 좋지 않다.
+ 크기를 늘릴 순 있어도 줄일 순 없어 여전히 메모리 낭비가 있다.
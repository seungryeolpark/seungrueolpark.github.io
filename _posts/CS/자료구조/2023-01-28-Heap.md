---
title: Heap
categories: cs-ds
---

[1. 힙의 개념](#힙의-개념)  
[2. 힙의 종류](#힙의-종류)  
[3. 힙의 구현](#힙의-구현)


## 힙의 개념
+ 힙은 완전 이진 트리의 일종으로 [우선순위 큐](#우선순위-큐)에 의해 만들어진 자료구조이다.
+ 여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다.
+ 힙은 일종의 [반정렬 상태(느슨한 정렬 상태)](#반정렬-상태)를 유지한다.
    + 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도
    + 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진 트리를 말한다.
+ 힙 트리에서는 중복된 값을 허용한다.(이진 탐색 트리에서는 중복된 값을 허용하지 않는다.)
+ 힙의 삽입과 삭제의 경우 연산 자체는 O(1)의 시간 복잡도를 가지지만 [heapify](#heapify)의 과정이 O(log n)이기 때문에
최종적으로 O(log n)의 시간 복잡도를 가진다.

### heapify
+ 배열로 표현된 이진 트리의 자료구조를 갖는 힙을 생성하는 과정

### 우선순위 큐
+ 우선순위의 개념을 큐에 도입한 자료구조
+ 데이터들이 우선순위를 가지고 있고 우선순위가 높은 데이터가 먼저 나간다.
+ 우선순위 큐는 배열, 연결리스트, 힙으로 구현이 가능하며 이 중에서 힙으로 구현하는 것이 가장 효율적이다.
    + 힙 : 삽입 O(logn), 삭제 O(logn)

### 반정렬 상태
+ 트리 구조를 배열로 저장한 것이므로 배열로만 보았을 때는 완전히 정렬된 상태로 보이지 않는다는 것이다.

## 힙의 종류
+ 최대 힙
    + 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
    + key(부모 노드) >= key(자식 노드)
+ 최소 힙
    + 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리
    + key(부모 노드) <= key(자식 노드)
![1.png](..%2F..%2F..%2F..%2F..%2F1.png)

## 힙의 구현
+ 힙을 저장하는 표준적인 자료구조는 배열이다.
+ 구현을 쉽게 하기 위해 배열의 첫 번째 인덱스인 0은 사용하지 않는다.
+ 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않는다.
    + 항상 인덱스 1은 루트 노드이며 2는 루트 노드의 왼쪽 노드이며 3은 루트 노드의 오른쪽 노드이다.
+ 힙에서 부모 노드와 자식 노드의 관계
    + 왼쪽 자식의 인덱스 = 부모의 인덱스*2
    + 오른쪽 자식의 인덱스 = 부모의 인덱스*2 + 1
    + 부모의 인덱스 = 자식의 인덱스/2

### 힙의 삽입
1. 힙에 새로운 노드가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.
2. 새로운 노드를 부모 노드들과 값을 비교해 교환해서 힙의 성질을 만족시킨다.

```java
// 최대힙 삽입
class Heap {
  void insert_max_heap(int x) {
    maxHeap[++heapSize] = x;

    for (int i=heapSize; i>1; i/=2) {
      // 마지막 노드가 자신의 부모 노드보다 크면 swap
      if (maxHeap[i/2] < maxHeap[i]) {
        swap(i/2, i);
      } else {
        break;
      }
    }
  }   
}
```

### 힙의 삭제
1. 최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제된다.
   + 최대 힙에서 삭제 연산은 최댓값을 가진 요소를 삭제하는 것이다.
2. 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.
3. 힙을 재구성한다.

```java
// 최대힙 삭제
class Heap {
  int delete_max_heap() {
    if (heapSize == 0) return 0;

    int item = maxHeap[1];
    maxHeap[1] = maxHeap[heapSize];
    maxHeap[heapSize--] = 0;

    for (int i=1; i*2<=heapSize;) {
      // 마지막 노드가 왼쪽 노드와 오른쪽 노드보다 크면 반복문을 나간다.
      if (maxHeap[i] > maxHeap[i*2] && maxHeap[i] > maxHeap[i*2+1]) {
        break;
      } // 왼쪽 노드가 더 큰 경우, 왼쪽 노드와 마지막 노드를 swap
      else if (maxHeap[i*2] > maxHeap[i*2+1]) {
        swap(i, i*2);
        i = i*2;
      } // 오른쪽 노드가 더 큰 경우, 오른쪽 노드와 마지막 노드를 swap
      else {
        swap(i, i*2+1);
        i = i*2+1;
      }
    }
    return item;
  }
}
```
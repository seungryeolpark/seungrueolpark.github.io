---
title: Graph
categories: cs-ds
---

[1. 그래프의 개념](#그래프의-개념)  
[2. 그래프의 특징](#그래프의-특징)  
[3. 그래프의 종류](#그래프의-종류)  
[4. 그래프의 구현](#그래프의-구현)  
[5. 그래프의 탐색](#그래프의-탐색)

## 그래프의 개념
+ [정점(vertex)](#정점)과 그 정점을 연결하는 간선(edge)을 하나로 모아 놓은 자료구조
+ 트리 또한 그래프이며 그 중 사이클이 허용되지 않는 그래프다.

### 정점
+ 위치라는 개념 (node 라고도 부름)

## 그래프의 특징
+ 그래프트는 네트워크 모델이다
+ 2개 이상의 경로가 가능하다
+ self-loop 뿐 아니라 loop/circuit 모두 가능하다.
+ 루트 노드라는 개념이 없다.
+ 순회는 [DFS](#깊이-우선-탐색--dfs-)나 [BFS](#너비-우선-탐색--bfs-)로 이루어진다.
+ 그래프는 [순환(Cyclic)](#사이클) 혹은 [비순환(Acyclic)](#비순환-그래프)이다.
+ 그래프는 크게 [방향 그래프](#방향-그래프)와 [무방향 그래프](#무방향-그래프)가 있다.
+ 간선의 유무는 그래프에 따라 다르다.

## 그래프의 종류
### 무방향 그래프 & 방향 그래프
#### 무방향 그래프
+ 무방향 그래프의 간선은 간선을 통해서 양방향으로 갈 수 있다.
+ 정점 A 와 정점 B 를 연결하는 간선은 (A, B)와 같이 정점의 쌍으로 표현한다.
    + (A, B)는 (B, A)와 동일

#### 방향 그래프
+ 간선에 방향성이 존재하는 그래프
+ A -> B 로만 갈 수 있는 간선은 <A, B>로 표시한다.
    + <A, B>는 <B, A>와 다름

### 가중치 그래프
+ 간선에 비용이나 가중치가 할당된 그래프
+ 네트워크라고도 한다.
    + ex) 도시-도시의 연결, 도로의 길이, 회로 소자의 용량, 통신망의 사용료 등

### 부분 그래프
+ 본래 그래프의 일부 정점 및 간선으로 이루어진 그래프

### 연결 그래프 & 비연결 그래프
#### 연결 그래프
+ 무방향 그래프에 있는 모든 정점 쌍에 대해서 항상 경로가 존재하는 경우
+ ex) 트리 : 사이클을 가지지 않는 연결 그래프

#### 비연결 그래프
+ 무방향 그래프에서 특히 정점 쌍 사이에 경로가 존재하지 않는 경우

### 사이클 & 비순환 그래프
#### 사이클
+ [단순 경로](#단순-경로)의 시작 정점과 종료 정점이 동일한 경우

#### 비순환 그래프
+ 사이클이 없는 그래프

##### 단순 경로
+ 경로 중에서 반복되는 정점이 없는 경우

### 완전 그래프
+ 그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프
+ 무방향 완전 그래프
    + 정점 수 : n이면 간선의 수 : n*(n-1)/2

## 그래프의 구현
### 인접 행렬
+ 정방 행렬을 사용하는 방법
+ matrix[i][j]가 true 라면 i -> j로의 간선이 있다는 뜻이다.
```java
if (간선 (i, j)가 그래프에 존재)
    matrix[i][j] = 1;
else
    matrix[i][j] = 0;
```
+ 정점 개수가 N인 그래프를 인접 행렬로 표현하면 간선의 수와 무관하게 항상 n<sup>2</sup>개의 메모리 공간이 필요하다.
+ 무방향 그래프를 인접 행렬로 표현한다면 이 행렬은 대칭 행렬이 된다.
    + 방향 그래프는 대칭 행렬이 안될 수도 있다.
### 인접 리스트
+ 인접 리스트로 그래프를 표현하는  것이 가장 일반적인 방법
+ 모든 정점은 인접 리스트에 저장한다. 즉 각각의 정점에 인접한 정점들을 리스트로 표시한 것이다.
    + 배열(혹은 해시테이블)과 배열의 각 인덱스마다 존재하는 또 다른 리스트(배열, ArrayList, Linked List 등)를 이용해서 인접 리스트를 표현
    + 정점의 번호만 알면 이 번호를 배열의 인덱스로 하여 각 정점의 리스트에 쉽게 접근할 수 있다.
    + ```java
      0: 1
      1: 2
      2: 0, 3
      3: 2
      4: 6
      5: 4
      6: 5
      ```
+ 무방향 그래프에서 (A, B) 간선은 두번 저장된다.
    + 한번은 A 정점에 인전합 간선을 저장하고 다른 한번은 B에 인접한 간선을 저장한다.
    + 정점의 수 : N, 간선의 수 E인 무방향 그래프이 경우
        + N개의 리스트, N개의 배열, 2E개의 노드가 필요
+ 트리에선 특정 노드 하나(루트 노드)에서 다른 모든 노드로 접근이 가능(Tree 클래스 불필요)
    + 그래프에선 특정 노드에서 다른 모든 노드로 접근이 가능하지는 않음(Graph 클래스 필요)
    + ```java
      class Graph { public Node[] nodes; }
      // 트리의 노드 클래스와 동일
      class Node {
        public String name;
        public Node[] children;
      }
      ```
      
### 인접 행렬 & 인접 리스트
#### 인접 행렬 장점 & 단점
+ 장점
    + 간선의 존재 여부 (M[i][j])를 O(1)안에 즉시 알 수 있다.
    + 정점의 [차수](#차수)는 O(N)안에 알 수 있다. : 인접 배열의 i번 째 행 또는 열을 모두 더한다.
+ 단점
    + 어떤 노드에 인접한 노드들을 찾기 위해서는 모든 노드를 전부 순회해야 한다.
    + 그래프에 존재하는 모든 간선의 수는 O(N<sup>2</sup>)안에 알 수 있다. : 인접 행렬 전체를 조사한다.

#### 인접 리스트 장점 & 단점
+ 장점
    + 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있다.
    + 그래프에 존재하는 모든 간선의 수는 O(N+E) 안에 알 수 있다. : 인접 리스트 전체를 조사한다.
+ 단점
    + 간선의 존재 여부와 정점의 차수 : 정점 i의 리스트에 있는 노드의 수, 정점 차수만큼의 시간이 필요

##### 차수
+ 정점에 부속되어 있는 간선의 수

## 그래프의 탐색
+ 그래프는 정점의 구성 뿐만 아니라 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다.
따라서 그래프의 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다.

### 깊이 우선 탐색(DFS)
+ 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 나아가는 방법을 우선으로 탐색한다.
연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더 이상 연결될 수 있는 정점이 없으면
바로 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 잇는지 살펴본다.
+ 모든 노드를 방문하고자 하는 경우 이 방법을 선택하고 너비 우선 탐색보다 좀 더 간단하다.
+ O(V+E) 시간 복잡도를 가진다.
+ ```java
  class DFS_stack {
    private boolean[] visited = new boolean[9];
    private int[][] graph = { {}, {2,3,8}, {1,6,8}, {1,5}, {5,7}, {3,4,7}, {2}, {4,5}, {1,2} };
    private Stack<Integer> stack = new Stack<>();
    
    void dfs(int start) {
        // 시작 노드 스택 처리
        stack.push(start);
        // 시작 노드 방문 처리
        visited[start] = true;
        
        while (!stack.isEmpty()) {
            int i = stack.pop();
            // 꺼낸 노드와 연결되어 있는 모든 노드 방문
            for (int node : graph[i]) {
                // 연결된 노드가 방문하지 않았을 경우 스택에 넣고 방문 처리
                if (!visited[node]) {
                    stack.push(node);
                    visited[node] = true;
                }
            }
        }
    }
  }
  ```

### 너비 우선 탐색(BFS)
+ 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아간다. 트리에서 레벨 순회 형식으로 진행되는 것이다. 
+ 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을때 이 방법을 선택한다.
+ O(V+E) 시간 복잡도를 가진다.
+ ```java
  class BFS_queue {
    private boolean[] visited = new boolean[9];
    private int[][] graph = { {}, {2,3,8}, {1,6,8}, {1,5}, {5,7}, {3,4,7}, {2}, {4,5}, {1,2} };
    private Queue<Integer> q = new LinkedList<Integer>();
  
    void bfs(int start) {
        // 시작 노드 큐 처리
        q.offer(start);
        // 시작 노드 방문 처리
        visited[start] = true;
  
        while (!q.isEmpty()) {
            int i = q.poll();
            // 꺼낸 노드와 연결되어 있는 모든 노드 체크
            for (int node : graph[i]) {
                // 연결된 노드가 방문하지 않았을 경우 큐에 넣고 방문 처리
                if (!visited[node]) {
                    stack.push(node);
                    visited[node] = true;
                }
            }
        }
    }
  }
  ```
---
title: 프로세스 동기화
categories: cs-os
---

[1. 데드락](#데드락)  
[2. 세마포어 & 뮤텍스](#세마포어--뮤텍스)

## 데드락
+ 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
  (무한히 다음 자원을 기다리게 되는 상태)
+ 데드락이 일어나는 경우

![](https://user-images.githubusercontent.com/48073115/217024018-ce0e745a-2391-4d17-a9bc-e4b6bfb96a95.png)

### 데드락 발생 조건
+ 4가지 모두 성립해야 데드락 발생(하나라도 성립하지 않으면 데드락 문제 해결 가능)
1. **상호 배제**
    + 자원은 한 번에 한 프로세스만 사용할 수 있음
2. **점유 대기**
    + 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을
   추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
3. **비선점**
    + 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
4. **순환 대기**
    + 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야함
   
### 데드락 처리
1. 예방
    + 교착 상태 발생 조건 중 하나를 제거하면서 해결한다.(자원 낭비가 심하다)
        + 상호배제: 여러 프로세스가 공유 자원 사용
        + 점유대기: 프로세스 실행전 모든 자원을 할당
        + 비선점: 자원 점유 중인 프로세스한테 다른 프로세스가 자원을 요구할 때 가진 자원 반납
        + 순환대기: 자원에 고유번호 할당 후 순서대로 자원 요구
2. 회피
    + 시스템에 순환 대기가 발생하지 않도록 자원 할당 상태를 검사한다.
        1. 자원 할당 그래프 알고리즘
            + 자원 유형이 단일 일때 사용하는 알고리즘
        2. 은행원 알고리즘
            + 자원 유형이 여러 개 일때 사용하는 알고리즘
            + 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래
            + 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지
          사전에 검사하여 교착 상태 회피
            + 안정 상태면 자원 할당 아니면 다른 프로세스들이 자원 해지까지 대기
3. 탐지
    + 자원 할당 그래프를 통해 교착 상태를 탐지함
    + 자원 요청 시 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함

4. 회복
    + 교착 상태를 일으킨 프로세스를 종료하거나 할당된 자원을 해제시켜 회복시키는 방법
        + 프로세스 종료 방법
            1. 교착 상태의 프로세스를 모두 중지 
            2. 교착 상태가 제거될 때 까지
        + 자원 선점 방법
            1. 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당
               (해당 프로세스 일시정지 시킴)
            2. 우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점

## 세마포어 & 뮤텍스
+ 공유된 자원에 여러 프로세스가 동시에 접근하면서 문제가 발생할 수 있다.
    + 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야 한다.

### 세마포어
+ 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법

#### 임계 구역(Critical Section)
+ 여러 프로세스가 데이터를 공유하며 수행될 때 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분
+ 공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에
한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.

#### 세마포어 P, V 연산
+ P: 임계구역 에 들어가기 전에 수행(프로세스 진입 여부를 자원의 개수(S)를 통해 결정)
+ V: 임계 구역에서 나올 때 수행(자원 반납 알림, 대기 중인 프로세스를 깨우는 신호)

```
P(S);
// --- 임계 구역 ---
V(S);

procedure P(S) // 최초 S값은 1임
    while S=0 do wait // S가 0이면 1이 될때까지 기다려야 함
    S := S-1 // S를 0으로 만들어 다른 프로세스가 들어오지 못하도록 함
end P

procedure V(S) // 현재 S값은 0임
    S := S+1 // S를 1로 원위치시켜 해제하는 과정
end V
```
+ 이를 통해 한 프로세스가 P 혹은 V를 수행하고 있는 동안 프로세스가 인터럽트 당하지 않게 된다.

### 뮤텍스
+ 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술
+ 해당 접근을 조율하기 위해 lock 과 unlock 을 사용한다.
    + lock: 현재 임계 구역에 들어갈 권한을 얻어옴.
      (만약 다른 프로세스/스레드가 임계 구역 진행 중이면 종료할 때까지 대기)
    + unlock: 현재 임계 구역을 모두 사용했음을 알림.
      (대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 있음)
+ 뮤텍스는 상태가 0, 1로 이진 세마포어로 부르기도 함

#### 뮤텍스 알고리즘
1. 데커 알고리즘
    + flag 와 turn 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정하는 방식
        + flag: 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수
        + turn: 누가 임계구역에 들어갈 차례인지 나타내는 변수
    
```
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
        if (trun == j) { // j가 임계 구역 사용 중이면
            flag[i] = false; // 프로세스 i 진입 취소
            while(trun == j) {} // trun 이 j에서 변경될 때까지 대기
            flag[i] = true; // j trun 이 끝나면 다시 진입 시도
        }
    }
}

// 임계 구역

trun = j; // 임계 구역 사용이 끝나면 turn 을 넘김
flag[i] = false; // flag 값을 false 로 바꿔 임계 구역 사용 완료를 알림
```

2. 피터슨 알고리즘
    + 데커와 유사하지만 상대방 프로세스/스레드에게 진입 기회를 양보하는 것에 차이가 있음
   
```
while(true) {
    flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
    turn = j; // 다른 프로세스에게 진입 기회 양보
    while(flag[j] && turn == j) {} // 다른 프로세스가 진입 시도하면 대기
}

// 임계 구역

flag[i] = false; // flag 값을 false 로 바꿔 임계 구역 사용 완료를 알림
```

3. 제과점 알고리즘
    + 여러 프로세스/스레드에 대한 처리가 가능한 알고리즘
    + 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계 구역에 진입한다.

```
while(true) {
    isReady[i] = true; // 번호표 받을 준비
    number[i] = max(number[0~n-1])+1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정
    isReady[i] = false; // 번호표 수령 완료
    
    for(j=0; j<n; j++) { // 모든 프로세스 번호표 비교
        while(isReady[j]) {} // 비교 프로세스가 번호표 받을 때까지 대기
        while(number[j] && number[j] < number[i] && j < i) {}
        // 프로세스가 보다 작은 수 또는 같은 수를 할당받을 때까지 대기
        // 보다 높은 우선순위가 도착하면 작업을 종료
    }
}

// 임계 구역

number[i] = 0; // 임계 구역 사용 종료
```
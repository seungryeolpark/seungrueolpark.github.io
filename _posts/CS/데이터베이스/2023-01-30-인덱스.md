---
title: 인덱스
categories: cs-database
---

[1. 인덱스](#인덱스)  
[2. 기본 인덱스 & 클러스터링 인덱스 & 보조 인덱스 & 다단계 인덱스](#기본-인덱스--클러스터링-인덱스--보조-인덱스--다단계-인덱스)

## 인덱스
+ 데이터베이스 안의 레코드를 처음부터 풀스캔하지 않고 B+ Tree 로 구성된 구조에서 Index 파일 검색으로 속도를 향상시키는 기술
+ 테이블의 기본 키는 자동으로 Index 된다.

### 인덱스의 목적
+ 해당 RDBMS 의 검색 속도를 높이는데 있다.
+ SELECT 쿼리의 WHERE 절이나 JOIN 예약어를 사용했을때만 인덱스가 사용되며
SELECT 쿼리의 검색 속도를 빠르게 하는데 목적을 두고 있다.
  (DELETE, INSERT, UPDATE 쿼리에는 해당 사항이 없으며 Index 사용 시 느려진다.)

### 인덱스 장점 & 단점
+ 장점
  + 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킨다.
  + 질의나 보고서에서 그룹화 작업의 속도를 향상시킨다.
  + Index 를 사용하면 테이블 행의 고유성을 강화시킬 수 있다.
+ 단점
  + Index 를 만들면 [.mdb 파일](#mdb-파일) 크기가 늘어난다.
  + 여러 사용자 응용 프로그램에서의 여러 사용자가 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
  + Index 된 필드에서 데이터를 UPDATE 하거나 레코드를 추가 또는 삭제할 때 성능이 떨어진다.
  + Index 가 데이터베이스 공간을 차지해 추가적인 공간이 필요해진다.(DB의 10% 내외 공간이 추가로 필요하다)
  + Index 를 생성하는데 시간이 많이 소요될 수 있다.
  + 데이터 변경 작업이 자주 일어날 경우에 Index 를 재작성해야 할 필요가 있기에 성능에 영향을 끼칠 수 있다.
+ Index 를 추가하면 쿼리 속도가 1초 정도 빨라지지만 데이터 행을 추가하는 속도는 2초 정도 느려지게 되어 여러 사용자가
사용하는 경우 레코드 잠금 문제가 발생할 수 있다.
+ 다른 필드에 대한 Index 를 만들게 되면 성능이 별로 향상되지 않을 수도 있다.
만드는 쿼리의 종류와 관계없이 가장 고유한 값을 갖는 필드만 Index 해야 한다.

### .mdb 파일
+ Microsoft Access Database 파일
+ XML 및 HTML 과 같은 다른 파일 및 Excel 및 SharePoint 와 같은 응용 프로그램의 데이터를 연결하고
저장하는 데 사용할 수 있는 데이터베이스 쿼리, 테이블 등이 있다.

### 파일 구조
+ 테이블 생성 시, 3가지 파일이 생성된다.
    + FRM : 테이블 구조 저장 파일
    + MYD : 실제 데이터 파일
    + MYI : Index 정보 파일 (Index 사용 시 생성)
+ 사용자가 쿼리를 통해 Index 를 사용하는 칼럼을 검색하게 되면, 이때 MYI 파일의 내용을 활용한다.

### 상황 분석
+ 사용하면 좋은 경우
  + Where 절에서 자주 사용되는 Column
  + 외래키가 사용되는 Column
  + Join 에 자주 사용되는 Column
+ 사용하면 안좋은 경우
  + Data 중복도가 높은 Column
  + DML 이 자주 일어나는 Column

### DML 이 일어났을 때의 상황
+ INSERT
  + 기존 Block 에 여유가 없을 때 새로운 Data 가 입력된다.
    + 새로운 Block 을 할당 받은 후 Key 를 옮기는 작업을 수행한다.
    + Index split 작업 동안 해당 Block 의 Key 값에 대해서 DML 이 블로킹 된다.(대기 이벤트 발생)
+ DELETE
  + Table 에서 Data 가 DELETE 되는 경우 : Data 가 지워지고 다른 Data 가 그 공간을 사용 가능하다.
  + Index 에서 Data 가 DELETE 되는 경우 : Data 가 지워지지 않고, 사용 안 됨 표시만 해둔다.
  + Table 의 Data 수와 Index 의 Data 수가 다를 수 있다.
+ UPDATE
  + Index 에는 UPDATE 개념이 없다.
  + 테이블에 UPDATE 가 발생한 경우 Index 에서 DELETE 가 먼저 발생한 후 새로운 작업의 INSERT 작업이 발생한다.
  DELETE 와 INSERT 두개의 작업이 Index 에 동시에 일어나 다른 DML 보다 더 큰 부하를 주게 된다.

## 기본 인덱스 & 클러스터링 인덱스 & 보조 인덱스 & 다단계 인덱스
### 기본 인덱스(Primary Index)
+ 탐색 키가 데이터 파일의 기본 키인 인덱스를 Primary Index 라 하고 
Primary Index 는 기본 키의 값에 따라 정렬된 데이터 파일에 대해 정의된다.
+ 전체 파일에 대한 탐색이 아니라 각 블록당 하나의 엔트리(블록의 앵커 엔트리에 대한 키 값)을 가지므로
기본 인덱스는 [희소 인덱스](#희소-인덱스) 이다.

#### 희소 인덱스
+ 일부 키 값에 대해서만 인덱스에 엔트리를 유지하는 인덱스
+ 일반적으로 각 데이터 블록마다 한 개의 탐색 키 값을 가진다.

![](https://user-images.githubusercontent.com/48073115/215390706-12e2c1a9-2396-4040-b518-293f6786da43.png)
<div align="center">출처 : 데이터베이스 배움터</div>

### 클러스터링 인덱스(Clustering Index)
+ 탐색 키 값에 따라 정렬된 데이터 파일에 대해 정의된다.
+ 범위 질의에 유용하다. 범위의 시작 값에 해당하는 인덱스 엔트리를 먼저 찾고 범위에 속하는 인덱스 인트리들을 따라가면서
레코드들을 검색할 때 디스크에서 읽어오는 블록 수가 최소화 된다.

![](https://user-images.githubusercontent.com/48073115/215390779-deea4bff-04dd-42c8-b7f5-2cef72eb2808.png)
<div align="center">출처 : 데이터베이스 배움터</div>

### 보조 인덱스(Secondary Index)
+ 탐색 키 값에 따라 정렬되지 않은 데이터 파일에 대해 정의된다.
+ 일반적으로 [밀집 인덱스](#밀집-인덱스)이므로 같은 수의 레코드들을 접근할 때
보조 인덱스를 통하면 기본 인덱스를 통하는 경우보다 디스크 접근 회수가 증가한다.

#### 밀집 인덱스
+ 각 데이터의 키 값마다 한 개의 엔트리를 가진다.

![](https://user-images.githubusercontent.com/48073115/215390847-af9f60a4-385c-478e-8f78-a86c9a21eb5c.png)
<div align="center">출처 : 데이터베이스 배움터</div>

### 다단계 인덱스
+ 인덱스 자체가 큰 경우에 인덱스를 탐색하는 시간도 오래걸린다.
그래서 인덱스 엔트리를 탐색하는 시간을 줄이기 위해 단일 단계 인덱스(기본 인덱스, 클러스터링 인덱스, 보조 인덱스)를
디스크 상의 하나의 순서 파일로 간주하고 단일 단계 인덱스에서 다시 인덱스를 정의할 수 있다.
이러한 과정은 가장 상위 단계의 모든 인덱스(마스터 인덱스) 엔트리들이 한 블록에 들어갈 수 있을 때까지 이 과정을 반복한다.
+ 각 인덱스들이 오름차순으로 정렬되어 있어야 하므로 인덱스의 갱신은 단일 단계 인덱스의 경우보다 복잡하다.
그러나 대부분의 데이터베이스 응용에서 갱신보다는 검색이 훨씬 자주 되므로 모든 DBMS 에서는
인덱스를 다단계 인덱스로 사용되고 보통 B+ Tree 동작 방식을 사용한다.

![](https://user-images.githubusercontent.com/48073115/215390899-9c618346-aee6-4f51-ae6f-575b842e5f97.png)
<div align="center">출처 : 데이터베이스 배움터</div>
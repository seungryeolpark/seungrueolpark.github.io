[//]: # (---)

[//]: # (title: "데이터베이스 심화")

[//]: # (categories: JP_TI)

[//]: # (---)

[//]: # ([1. 인덱스]&#40;#인덱스&#41;  )

[//]: # ([2. 정규화]&#40;#정규화&#41;  )

[//]: # ([3. 트랜잭션]&#40;#트랜잭션&#41;  )

[//]: # ([4. NoSQL]&#40;#NoSQL&#41;  )

[//]: # ([5. Redis]&#40;#Redis&#41;  )

[//]: # ()
[//]: # (## 인덱스)

[//]: # (### 장점과 단점)

[//]: # (+ 장점)

[//]: # (  + 원하는 데이터를 빠르게 찾을 수 있다.)

[//]: # (+ 단점)

[//]: # (  + 타 성능 악영향)

[//]: # (    + INSERT / UPDATE / DELETE의 성능에 영향을 미친다.)

[//]: # (    + 인덱스를 걸어둔 컬럼의 데이터가 바뀌면 인덱스 테이블의 수정도 필요하기 때문에 작업이 두 번 이루어지게 되는 것이다.)

[//]: # (  + 추가 저장 공간 필요)

[//]: # (    + 인덱스 key 값으로 가지려면 별도의 공간에 저장하므로 추가 저장 공간이 필요하다.)

[//]: # (    + 인덱스 영역을 전체 테이블 영역의 30 ~ 50%까지 잡아 놓을 만큼 저장 공간이 많이 필요하다.)

[//]: # (  + 공수 필요)

[//]: # (    + 인덱스를 생성하고 주기적으로 관리할 공수 즉 인력과 시간이 들어간다.)

[//]: # (  + 잘못 사용할 경우 오히려 성능 저하)

[//]: # (    + 인덱스의 크기가 비대해져 성능이 오히려 저하되는 역효과)

[//]: # (    + UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다.)

[//]: # (+ 단점이 많음에도 불구하고 일반적인 시스템에서 데이터 조회 업무가 90% 이상이기 때문에 RDBMS에서 인덱스는 필수다.)

[//]: # (+ 인덱스가 사용하기 좋은 환경)

[//]: # (  + 규모가 작지 않은 테이블에서)

[//]: # (  + INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼,)

[//]: # (  + JOIN / WHERE / ORDERBY가 자주 사용되는 컬럼.)

[//]: # (  + 데이터의 중복도가 낮은 컬럼)

[//]: # ()
[//]: # (### 자료구조)

[//]: # (+ 해시 테이블)

[//]: # (  + 시간복잡도가 O&#40;1&#41;이라 빠른 데이터 검색이 필요할 때 유용하다.)

[//]: # (  + 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산&#40;>, <&#41;이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.)

[//]: # (+ B+Tree)

[//]: # (  + 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조)

[//]: # (    + 각 노드에 데이터가 저장된 B Tree와 달리 리프노드만 인덱스와 함께 데이터를 가지고 있고, 나머지 노드들은 데이터를 위한 인덱스만을 갖는다.)

[//]: # (    + B Tree의 경우 최상 케이스에서 루트에서 끝날 수 있지만 B+ Tree는 무조건 리프노드까지 내려가야한다.)

[//]: # (    + 리프노드들은 LinkedList로 연결되어 있다.)

[//]: # (    + 데이터 노드 크기는 인덱스 노드 크기와 같지 않아도 된다.)

[//]: # (    + B+ Tree는 add와 delete가 모두 리프노드에서만 일어난다.)

[//]: # ()
[//]: # (![B+ Tree Structure]&#40;https://user-images.githubusercontent.com/48073115/148294843-20e0c681-02fb-4a91-bcf5-e12c0a4eff18.png&#41;)

[//]: # ()
[//]: # (#### 클러스터 인덱스와 비클러스터 인덱스 비교)

[//]: # (<table>)

[//]: # (  <thead>)

[//]: # (    <tr>)

[//]: # (      <th>기준</th>)

[//]: # (      <th width="40%">클러스터 인덱스</th>)

[//]: # (      <th width="40%">비클러스터 인덱스</th>)

[//]: # (    </tr>)

[//]: # (  </thead>)

[//]: # (  <tbody>)

[//]: # (    <tr>)

[//]: # (      <td>속도</td>)

[//]: # (      <td>빠르다</td>)

[//]: # (      <td>느리다</td>)

[//]: # (    </tr>)

[//]: # (    <tr>)

[//]: # (      <td>사용 메모리</td>)

[//]: # (      <td>적다</td>)

[//]: # (      <td>많다</td>)

[//]: # (    </tr>)

[//]: # (    <tr>)

[//]: # (      <td>인덱스</td>)

[//]: # (      <td>인덱스가 주요 데이터</td>)

[//]: # (      <td>인덱스가 데이터의 사본&#40;copy&#41;</td>)

[//]: # (    </tr>)

[//]: # (    <tr>)

[//]: # (      <td>개수</td>)

[//]: # (      <td>한 테이블에 한개</td>)

[//]: # (      <td>한 테이블에 여러 개&#40;최대 약 250개&#41;</td>)

[//]: # (    </tr>)

[//]: # (    <tr>)

[//]: # (      <td>리프 노드</td>)

[//]: # (      <td>리프 노드 자체가 데이터</td>)

[//]: # (      <td>리프 노드는 데이터가 저장되는 위치</td>)

[//]: # (    </tr>)

[//]: # (    <tr>)

[//]: # (      <td>저장값</td>)

[//]: # (      <td>데이터를 저장한 블록의 포인터</td>)

[//]: # (      <td>값과 데이터의 위치를 가리키는 포인터</td>)

[//]: # (    </tr>)

[//]: # (    <tr>)

[//]: # (      <td>정렬</td>)

[//]: # (      <td>인덱스 순서와 물리적 순서가 일치</td>)

[//]: # (      <td>인덱스 순서와 물리적 순서가 불일치</td>)

[//]: # (    </tr>)

[//]: # (  </tbody>)

[//]: # (</table>)

[//]: # ()
[//]: # (## 정규화)

[//]: # (### 정규화 비정규화)

[//]: # (+ 정규화)

[//]: # (  + 데이터 무결성을 유지하기 위해 테이블을 분할하여 데이터베이스에서 중복 데이터를 제거하는 프로세스이다.)

[//]: # (  + RDBMS에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다.)

[//]: # (  + 많은 저장 공간을 절약한다.)

[//]: # (+ 비정규화)

[//]: # (  + 복잡한 쿼리 속도를 높이고 성능을 향상시키기 위해 테이블에 중복 데이터를 추가하는 프로세스이다.)

[//]: # ()
[//]: # (### 정규화 장점과 단점)

[//]: # (+ 장점)

[//]: # (  + 데이터베이스 변경 시 이상 현상을 제거하고, 데이터베이스 구조 확장 시 재디자인을 최소화한다.)

[//]: # (+ 단점)

[//]: # (  + 릴레이션 분해로 인해 릴레이션 간의 연산&#40;join&#41;이 많아집니다. 이로 인해 응답 시간이 느려질 수 있다.)

[//]: # ()
[//]: # (+ 데이터 무결성은 데이터의 정확성, 일관성, 유효성이 유지되는 것을 말한다.)

[//]: # ()
[//]: # (## 트랜잭션)

[//]: # (### 트랜잭션의 성질&#40;ACID&#41;)

[//]: # (+ Atomicity&#40;원자성&#41;)

[//]: # (  + 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.)

[//]: # (  + 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.)

[//]: # (+ Consistency&#40;일관성&#41;)

[//]: # (  + 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.)

[//]: # (  + 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.)

[//]: # (+ Isolation&#40;독립성&#41;)

[//]: # (  + 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.)

[//]: # (  + 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.)

[//]: # (+ Durablilitu&#40;영속성&#41;)

[//]: # (  + 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.)

[//]: # ()
[//]: # (### 트랜잭션 격리수준)

[//]: # (+ 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것이다.)

[//]: # (+ 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정한다.)

[//]: # ()
[//]: # (#### READ UNCOMMITTED &#40;트랜잭션 레벨 0&#41;)

[//]: # (+ 트랜잭션에 처리 중인, 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.)

[//]: # (+ Dirty Read, Non-Repeatable Reead, Phantom Read 현상이 발생한다.)

[//]: # (+ 데이터 정합성에 문제가 많다. 그렇기에 RDBMS 표준에서는 격리수준으로 인정하지 않는다.)

[//]: # ()
[//]: # (#### READ COMMITTED &#40;트랜잭션 레벨 1&#41;)

[//]: # (+ RDBMS에서 대부분 기본적으로 사용되고 있는 격리 수준)

[//]: # (+ 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다.)

[//]: # (+ Non-Repeatable Read, Phantom Read 현상이 발생한다.)

[//]: # (+ 온라인 서비스에서 가장 많이 선택되는 격리수준이다.)

[//]: # (  + DB2, SQL server, Sybase의 경우 읽기, 공유 Lock을 이용하여 구현한다.)

[//]: # (  + Oracle은 Lock을 사용하지 않고 쿼리시작 시점의 Undo 데이터를 제공한다.)

[//]: # (+ Non-REPEATABLE READ 부정합 문제가 발생할 수 있다.)

[//]: # ()
[//]: # (#### REPEATABLE READ &#40;트랜잭션 레벨 2&#41;)

[//]: # (+ 트랜잭션이 시작되기 전에 COMMIT된 내용에 대해서만 조회할 수 있는 격리수준이다.)

[//]: # (+ Phantom Read 현상이 발생한다.)

[//]: # ()
[//]: # (#### SERIALIZABLE &#40;트랜잭션 레벨 3&#41;)

[//]: # (+ 선행 트랜잭션이 특정 테이블을 읽는 경우&#40;SELECT&#41; 공유 잠금&#40;shared lock&#41; 을 걸어, 다른 트랜잭션에서 해당 테이블의 데이터를 UPDATE, DELETE, INSERT 작업을 못하도록 막는다.)

[//]: # (+ 동시 처리 능력이 다른 격리수준보다 떨어지고 성능저하가 발생하여 데이터베이스에서 거의 사용하지 않는다.)

[//]: # ()
[//]: # (+ Dirty Read : 변경 후 아직 Commit 되지 않은 값을 읽고, Rollback 후의 값을 다시 읽어 최종 결과값이 상이한 현상이다.)

[//]: # (+ Non-Repeatable Read : 한 트랜잭션 내에서 같은 쿼리를 두번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리가 상이하게 나타나는 비 일관성이 발생하는 현상이다.)

[//]: # (+ Phantom Read : 하나의 트랜잭션에서 같은 쿼리를 두 번 실행했을 경우, 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타나는 현상이다.)

[//]: # ()
[//]: # (#### Lock)

[//]: # (+ 트랜잭션 처리의 순차성을 보장하기 위한 방법)

[//]: # (+ Shared Lock&#40;공유 잠금&#41;)

[//]: # (  + 데이터를 읽을 때 사용되어지는 Lock이다.)

[//]: # (  + 공유 Lock끼리는 동시에 접근이 가능하다.)

[//]: # (  + 공유 Lock이 설정된 데이터에 베타 Lock을 사용할 수는 없다.)

[//]: # (+ Exclusive Lock&#40;베타 잠금&#41;)

[//]: # (  + 데이터를 변경하고자 할 때 사용되어지는 Lock이다.)

[//]: # (  + Lock이 해제될 때까지 다른 트랜잭션&#40;읽기 포함&#41;은 해당 리소스에 접근 할 수 없다.)

[//]: # (  + 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함깨 Lock을 설정할 수 없습니다.)

[//]: # ()
[//]: # (### NoSQL)

[//]: # (+ 수십년간 사용되어오던 RDBMS 방식으로는 더이상 처리할 수 없을만큼의 복잡하고 큰 데이터들의 등장으로, NoSQL에 대한 필요성이 부각되기 시작했다.)

[//]: # (+ Not Only SQL의 약자로써, RDBMS와 반대되는 방식으로 사용하며, 데이터 테이블 간의 관계를 정의하지 않습니다.)

[//]: # (+ 따라서 정해진 스키마가 없어, 보다 자유롭게 데이터를 저장할 수 있습니다.)

[//]: # (+ RDBMS로는 관리할 수 없는 복잡하고 용량이 큰 데이터들을 관리 할 수 있도록 하기 위한 목적으로 등장했다.)

[//]: # (+ Key 값만 가지고 데이터에 대한 입출력을 수행할 수 있습니다.)

[//]: # ()
[//]: # (#### NoSQL vs RDBMS)

[//]: # (+ RDBMS)

[//]: # (  + 장점)

[//]: # (    + 데이터의 분류, 정렬, 탐색 속도가 비교적 빠름)

[//]: # (    + SQL이라는 구조화 된 질의를 통해 데이터를 다룰 수 있음)

[//]: # (    + 작업의 완전성을 보장함)

[//]: # (    + 데이터의 UPDATE가 빠름)

[//]: # (  + 단점)

[//]: # (    + 반드시 스키마 규격에 맞춰서 데이터를 다뤄야함)

[//]: # (    + 데이터 처리에 대한 부하 발생시 처리가 어려움)

[//]: # (+ NoSQL)

[//]: # (  + 장점)

[//]: # (    + 데이터간의 관계를 정의하지 않음&#40;테이블간의 관계&#40;join&#41; 불필요&#41;)

[//]: # (    + RDBMS보다 복잡도가 떨어져, 훨씬 대용량의 데이터를 저장, 관리 할 수 있음)

[//]: # (    + 테이블에 스키마가 정해져있지 않아 데이터 저장이 비교적 자유로움)

[//]: # (    + 많은 양의 데이터를 저장, 처리 할 수 있음)

[//]: # (  + 단점)

[//]: # (    + key값에 대한 입출력만 지원)

[//]: # (    + 스키마가 정해져 있지 않아, 데이터에 대한 규격화가 되어있지 않음)

[//]: # (    + DATA를 UPDATE하는데 비교적 느림)

[//]: # ()
[//]: # (#### NoSQL DB 종류)

[//]: # (1. Document Database)

[//]: # (  + 일반적으로 가장 많이 알려진 NoSQL이다.)

[//]: # (  + 테이블 스키마가 유동적이라 레코드마다 각각 다른 스키마를 가질 수 있다.)

[//]: # (  + XML, JSON과 같은 Document를 이용해 레코드를 저장한다.)

[//]: # (  + 트리형 구조로 레코드를 저장하거나 검색하는데 좋은 Database이다.)

[//]: # (  + 대표적인 Document Database : MongoDB, OrientDB)

[//]: # (2. Wide Column Database)

[//]: # (  + 행마다 키와 해당값을 저장할 때마다 각각 다른 값의 다른 수의 스키마를 가질 수 있다.)

[//]: # (  + 사용자 이름&#40;key&#41;에 해당하는 값에 스키마들이 각각 다른 구조를 갖고 있다.)

[//]: # (  + 대량의 데이터의 압축, 분산처리, 집계처리&#40;sum, count, avg 등&#41; 및 쿼리 동작 속도 그리고 확장성이 뛰어난 것이 특징이다.)

[//]: # (  + 대표적인 Wide Column Database : Google BigTable, HyperTable)

[//]: # (3. Key Value Database)

[//]: # (  + 기본적인 패턴으로 Key, Value 가 하나의 묶음으로 저장되는 구조로 단순한 구조이기에 속도가 빠르며 분산 저장 시 용이하다.)

[//]: # (  + Key 안에 &#40;Column, Value&#41; 형태로 된 여러개의 필드를 갖습니다.)

[//]: # (  + 엑세스 속도는 빠르지만 Scan에는 용이하지 않습니다.)

[//]: # (  + 대표적인 Key Value Database : Redis)

[//]: # (4. Graph Database)

[//]: # (  + 데이터를 노드로 표현하며, 노드 사이의 관계를 엣지로 표현)

[//]: # (  + RDBMS 보다 Performance가 좋고 유연하며 유지보수에 용이한 것이 특징)

[//]: # (  + Social networks, Network diagrams 등에 사용할 수 있다)

[//]: # (  + 대표적인 Graph Database : Neo4j, OrientDB)

[//]: # ()
[//]: # (### Redis)

[//]: # (+ 장점)

[//]: # (  + 리스트, 배열 형식의 데이터 처리에 특화)

[//]: # (    + 문자열, 리스트, set, sorted set, hash 등 여러 데이터 형식을 지원한다.)

[//]: # (    + 리스트형 데이터의 입력과 삭제가 mysql에 비해 10배 정도 빠르다.)

[//]: # (  + 메모리를 활용하면서 영속적인 데이터 보존)

[//]: # (    + 명령어로 명시적으로 삭제하거나 expires를 설정하지 않으면 데이터를 삭제하지 않습니다.)

[//]: # (    + 스냅샷 기능을 제공하여 메모리의 내용을 파일로 저장하여 해당 시점으로 복구가 가능하다.)

[//]: # (  + 싱글 스레드)

[//]: # (    + 싱글 스레드로 처리되기 때문에 원자성은 보장된다.)

[//]: # (    + 여러 개의 명령어를 처리하지 못하기 때문에 시간 복잡도를 고려하여 명령어를 사용해야 한다.)

[//]: # (+ 단점)

[//]: # (  + 메모리 기반으로 계속 메모리에 데이터를 추가하는데 한계가 존재해 장기적 데이터 저장에는 불리합니다.)

[//]: # (  )

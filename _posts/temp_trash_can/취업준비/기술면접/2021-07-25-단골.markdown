[//]: # (---)

[//]: # (title: "단골 질문")

[//]: # (categories: JP_TI)

[//]: # (---)

[//]: # ()
[//]: # (## 프레임워크와 라이브러리의 차이점)

[//]: # (+ 프레임워크 : 내가 작성한 코드를 제어하고, 대신 실행한다.)

[//]: # (+ 라이브러리 : 내가 작성한 코드가 직접 제어의 흐름을 담당한다.)

[//]: # ()
[//]: # (### 프레임워크란)

[//]: # (+ 일정 수준 이상의 품질을 보증하는 코드를 비교적 빠르고 편하게 완성 및 유지보수 할 수 있는 솔루션 )

[//]: # (+ 개발자들이 개발에 집중할 수 있도록 전체적인 틀을 제공해줌)

[//]: # ()
[//]: # (### 라이브러리란)

[//]: # (+ 쓸만한 기능들을 모아놓은 유틸 모음집)

[//]: # ()
[//]: # (## 객체 지향 프로그래밍&#40;OOP&#41;의 특징)

[//]: # (+ 프로그램에 필요한 데이터들의 묶음을 하나의 객체로 만들고, 이 객체들간의 유기적인 관계를 통해서 프로그램을 만드는 방법)

[//]: # (+ 각 객체들은 서로 데이터를 주고받으면서 역할을 수행한다.)

[//]: # (+ 자바의 경우 구성단위는 클래스에 해당)

[//]: # (+ **객체 지향 특징**)

[//]: # (    + 캡슐화)

[//]: # (    + 추상화)

[//]: # (    + 상속성)

[//]: # (    + 다형성)

[//]: # ()
[//]: # (### 객체 지향 프로그래밍&#40;OOP&#41;의 장점)

[//]: # (+ 코드 재사용성이 높다.)

[//]: # (+ 코드의 변경이 용이하다.)

[//]: # (+ 직관적인 코드 분석이 가능하다.)

[//]: # (+ 개발속도가 향상된다.)

[//]: # (+ 상속을 통한 장점을 극대화한다.)

[//]: # ()
[//]: # (## MVC 모델1과 MVC 모델2)

[//]: # (**MVC 모델1**)

[//]: # ()
[//]: # (![MVC1]&#40;https://user-images.githubusercontent.com/48073115/126879788-788def62-f428-4e94-ab02-57f1a8b26447.png&#41;)

[//]: # ()
[//]: # (+ 사용자의 요청을 JSP가 전부 다 처리한다.)

[//]: # (+ 웹브라우저 사용자의 요청을 받은 JSP는 자바빈이나 서비스 클래스를 사용하여 웹브라우저가 요청한 작업을 처리하고 그 결과를 출력한다.)

[//]: # ()
[//]: # (**MVC 모델2**)

[//]: # ()
[//]: # (![MVC2]&#40;https://user-images.githubusercontent.com/48073115/126879791-f670c30e-2d17-4142-b72d-934fb72e2aff.png&#41;)

[//]: # ()
[//]: # (+ 결과 표출화면&#40;View&#41;과 데이터 처리&#40;Model&#41;를 분리하여 재사용이 가능하도록 하는 구조)

[//]: # (+ 개발자의 영역과 웹 퍼블리셔의 영역을 분리할 수 있어 작업의 효율성을 높일 수 있다.)

[//]: # (    + 모델&#40;Model&#41; : 데이터 혹은 데이터를 처리하는 영역)

[//]: # (    + 뷰&#40;View&#41; : 결과 화면을 표출하는데 사용하는 자원)

[//]: # (    + 컨트롤러&#40;Controller&#41; : 뷰와 모델 사이에서 웹의 요청&#40;request&#41;을 연결해주는 중간 통신역할)

[//]: # (    )
[//]: # (## JDBC)

[//]: # (+ 자바 데이터베이스 커넥티비티&#40;JavaDatabaseConnectivity&#41;의 약자로, 다양한 DBMS와 연결하여 데이터를 주고받을 수 있게 해주는 프로그래밍 인터페이스)

[//]: # ()
[//]: # (## 자료구조)

[//]: # (+ 자료구조는 데이터를 효율적으로 저장, 관리하여 메모리를 효율적으로 사용하기 위해 필요하다.)

[//]: # (+ 적절한 자료구조의 사용은 메모리의 용량을 절약해주고, 실행시간을 단축시킨다.)

[//]: # (+ **자료구조의 특징**)

[//]: # (    + 효율성)

[//]: # (    + 추상화)

[//]: # (    + 재사용성)

[//]: # ()
[//]: # (### 자료구조 종류)

[//]: # (+ 배열)

[//]: # (    + 데이터를 논리적 순서에 따라 순차적으로 데이터를 입력하며, 물리적 주소 또한 순차적이다.)

[//]: # (    + 인덱스를 가지고 있어 원하는 데이터를 한번에 접근이 가능하기에 데이터 접근 속도가 매우 빠르다.)

[//]: # (    + 데이터의 삽입, 삭제에는 취약하다.)

[//]: # (    )
[//]: # (+ 연결리스트)

[//]: # (    + 데이터를 논리적 순서에 따라 데이터를 입력하지만, 물리적 주소는 순차적이지 않다.)

[//]: # (    + 인덱스 대신 현재 위치의 이전 및 다음 위치만을 기억한다. 따라서 한번에 데이터 접근이 가능하지 않다.)

[//]: # (    + 데이터 삽입, 삭제는 논리적 주소만 바꿔주면 되기때문에 용이하다.)

[//]: # (    )
[//]: # (+ 스택)

[//]: # (    + 같은 구조와 크기의 자료를 쌓아 올리는 개념)

[//]: # (    + 가장 마지막에 삽입&#40;PUSH&#41;된 자료가 가장먼저 삭제&#40;POP&#41;됨.)

[//]: # (    + LIFO&#40;Last-In-First-Out&#41;)

[//]: # (    )
[//]: # (+ 큐)

[//]: # (    + 줄을 서서 기다리는 것과 같은 개념)

[//]: # (    + 가장 먼저 삽입&#40;enQueue&#41;된 자료가 가장 먼저 삭제&#40;deQueue&#41;됨.)

[//]: # (    + FIFO&#40;First-In-First-Out&#41;)

[//]: # (    )
[//]: # (+ 힙)

[//]: # (    + 우선순위 큐로써 배열을 이용해서 보통 구현)

[//]: # (    + 최솟값 최대값을 빠르게 찾아낼 수 있다.)

[//]: # (    )
[//]: # (+ 그래프)

[//]: # (    + 노드와 노드들을 연결하는 간선을 가진 자료구조)

[//]: # (    + 사이클을 가질 수 있고 방향성, 무방향성을 가짐)

[//]: # (        + 방향성 : 간선에 방향성이 존재하는 그래프, 한쪽 방향으로만 갈 수 있음)

[//]: # (        + 무방향성 : 간선에 방향성이 존재하지 않는 그래프, 양방향으로 갈 수 있음)

[//]: # (    )
[//]: # (+ 트리)

[//]: # (    + 사이클이 없는 하나의 방향성이 있는 그래프)

[//]: # (    + 이진트리 : 자식노드를 최대 2명을 가지는 트리)

[//]: # (    + 완전 이진트리 : 마지막 레벨을 제외하고 꽉차있고 마지막 레벨은 왼쪽부터 순서대로 차있는 트리)

[//]: # (    )
[//]: # (## 자바 Collection의 종류와 차이점)

[//]: # (![단골1]&#40;https://user-images.githubusercontent.com/48073115/127004340-69e8386e-c031-4b4b-8445-bc5940ccd232.png&#41;)

[//]: # ()
[//]: # (Collection 인터페이스는 크게 List, Set, Queue로 3가지 상위 인터페이스로 분류할 수 있다. )

[//]: # (그리고 여기에 Map의 경우 Collection 인터페이스를 상속받고 있지 않지만 Collection으로 분류된다.)

[//]: # ()
[//]: # (### Collection 인터페이스의 특징)

[//]: # (+ Set 인터페이스)

[//]: # (    + 순서를 유지하지 않는 데이터의 집합으로 데이터의 중복을 허용하지 않는다.)

[//]: # (        + HashSet)

[//]: # (            + 가장빠른 임의 접근 속도)

[//]: # (            + 순서를 예측할 수 없음)

[//]: # (        + TreeSet)

[//]: # (            + 정렬방법을 지정할 수 있음)

[//]: # ()
[//]: # (+ List 인터페이스)

[//]: # (    + 순서가 있는 데이터의 집합으로 데이터의 중복을 허용한다.)

[//]: # (        + LinkedList)

[//]: # (            + 양방향 포인터 구조로 데이터의 삽입, 삭제가 빈번할 경우 데이터의 위치정보만 수정하면 되기에 유용)

[//]: # (            + 스택, 큐, 양방향 큐 등을 만들기 위한 용도로 쓰임)

[//]: # (        + Vector)

[//]: # (            + 과거에 대용량 처리를 위해 사용했으며, 내부에서 자동으로 동기화처리가 일어나 비교적 성능이 좋지않고 무거워서 잘 쓰이지 않음)

[//]: # (        + ArrayList)

[//]: # (            + 단방향 포인터 구조로 각 데이터에 대한 익세스를 가지고 있어 조회 기능 성능이 뛰어남)

[//]: # ()
[//]: # (+ Queue 인터페이스)

[//]: # (    + List와 유사)

[//]: # (        + LinkedList )

[//]: # (        + PriorityQueue)

[//]: # ()
[//]: # (+ Map 인터페이스)

[//]: # (    + 키와 값의 쌍으로 이루어진 데이터의 집합으로, )

[//]: # (    + 순서는 유지되지 않으며, 키의 중복을 허용하지 않으나 값의 중복은 허용한다.)

[//]: # (        + Hashtable)

[//]: # (            + HashMap보다는 느리지만 동기화 지원)

[//]: # (            + null 불가)

[//]: # (        + HashMap)

[//]: # (            + 중복과 순서가 허용되지 않으며 null값이 올 수 있다.)

[//]: # (        + TreeMap)

[//]: # (            + 정렬된 순서대로 키와 값을 저장하여 검색이 )

[//]: # (## CallByValue와 CallByReference)

[//]: # (값을 복사를 하여 처리하느냐, 아니면 직접 참조를 하느냐 차이)

[//]: # ()
[//]: # (### CallByValue&#40;값에 의한 호출&#41;)

[//]: # (+ 인자로 받은 값을 복사하여 처리)

[//]: # (+ 장점 : 복사하여 처리하기 때문에 안전하다. 원래의 값이 보존이 된다.)

[//]: # (+ 단점 : 복사를 하기 때문에 메모리가 사용량이 늘어난다.)

[//]: # ()
[//]: # (### CallByReference&#40;참조에 의한 호출&#41;)

[//]: # (+ 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 준다.)

[//]: # (+ 장점 : 복사하지 않고 직접 참조를 하기에 빠르다.)

[//]: # (+ 단점 : 직접 참조를 하기에 원래 값이 영향을 받는다.&#40;리스크&#41;)

[//]: # ()
[//]: # (## static의 위험성)

[//]: # (+ Static은 클래스 로딩 시, 메모리 공간을 할당하여 처음 설정된 메모리 공간이 변하지 않고 프로그램이 종료될 때 해체된다.)

[//]: # (+ 보통의 경우 여러 동작에서 공통적으로 요구되는 것들을 정적으로 설정하여 사용한다.)

[//]: # (+ 객체를 아무리 많이 만들어도 해당 변수는 하나만 존재&#40;객체와 무관한 키워드&#41;)

[//]: # (+ Static은 공유자원의 개념으로, 캡슐화 원칙에 위배되기 때문에 객체지향적이지 않다.)

[//]: # (+ 사용하고 있지 않더라도 프로그램이 실행되고 있는 내내 Static이 살아 있으므로, 메모리 낭비가 된다.)

[//]: # (+ Interface를 구현하는데 사용될 수 없으므로 재사용성이 떨어진다.)

[//]: # ()
[//]: # (## 오버라이딩과 오버로딩의 차이점)

[//]: # (### 오버로딩)

[//]: # (+ 동일한 이름의 함수로 재정의)

[//]: # (+ 이름이 동일하지만, 서로 다른 매개변수를 가짐.)

[//]: # ()
[//]: # (### 오버라이딩)

[//]: # (+ 부모 클래스 함수를 재정의하여 사용)

[//]: # (+ 동일한 이름, 같은 매개변수 타입과 수, 같은 리턴타입을 가져야함.)

[//]: # ()
[//]: # (## 세션과 쿠키)

[//]: # (### 쿠키)

[//]: # (+ 클라이언트 로컬에 저장되는 Key-value 형태의 데이터)

[//]: # ()
[//]: # (![단골2]&#40;https://user-images.githubusercontent.com/48073115/127155650-f07601a3-73fe-41d1-9842-cba19e5de973.png&#41;)

[//]: # ()
[//]: # (### 세션)

[//]: # (+ 세션은 기본적으로 쿠키를 사용한다. 하지만 세션 id만 쿠키로 저장하고, 상태 데이터들은 세션 id를 사용하여 서버에 저장한다.)

[//]: # ()
[//]: # (![단골3]&#40;https://user-images.githubusercontent.com/48073115/127156108-75ea6aab-177c-4fdd-adee-a67bcb2b54e1.png&#41;)

[//]: # ()
[//]: # (### 비교)

[//]: # ()
[//]: # (|  |쿠키|세션|)

[//]: # (|---|---|---|)

[//]: # (|저장 위치|클라이언트|서버|)

[//]: # (|보안|안좋음|좋음|)

[//]: # (|서버 부하|없음|높음|)

[//]: # (|생명주기|브라우저 종려해도 유지|브라우저 종료시 소멸|)

[//]: # (|속도|빠름|느림|)

[//]: # ()
[//]: # (출처 - [신입 java 웹 개발자 기술면접 대비]&#40;https://hellcoding.tistory.com/entry/%EC%8B%A0%EC%9E%85-java-%EC%9B%B9-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84&#41;)

---
title: "스프링 프레임워크"
categories: JP_TI
---

[1. Framework](#Framework)  
[2. Spring Framework](#Spring-Framework)  
[3. Spring MVC 구조의 처리과정](#Spring-MVC-구조의-처리과정)  
[4. Spring boot](#Spring-boot)
[5. Spring Annotation](#Spring-Annotation)  
[6. Spring Security 요청 과정](#Spring-Security-요청-과정)  
[7. JPA](#JPA)

## Framework
+ 특정 형태의 소프트웨어 문제를 해결하기 위해 상호 협력하는 클래스 프레임과 인터페이스 프레임의 집합
+ 특정한 틀을 만들어 놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들어 작업시간을 줄이는 것
+ 프레임워크는 특정 개념들의 추상화를 제공하고 여러 클래스나 컴포넌트로 구성된다.
+ 프레임워크는 이렇게 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의한다.
+ 프레임워크는 좀 더 높은 수준에서 패턴을 조작한다.

### 프레임워크가 중요한 이유
+ 객체지향 개발을 하게 되면서 개발자의 취향에 따라 다양한 프로그램이 나오게 되었다.
+ 프로그램 개발에 투입되는 개발자도 점점 늘어남에 따라 **전체 시스템의 통합성, 일관성이 부족하게 되었기 때문이다.**
+ 그래서 **개발자의 자유를 제한**하기 위해 프레임워크를 도입했다.

### 프레임워크 특징
+ 개발자들이 따라야할 가이드라인을 가진다.
+ 개발할 수 있는 범위가 정해져 있다.
+ 개발자를 위한 다양한 도구들이 지원된다.

### 프레임워크 장단점
+ 장점
  + 개발 시간을 줄일 수 있고 오류로부터 자유로울 수 있다.
+ 단점
  + 프레임워크에 너무 의존하면 개발 능력이 떨어져서 프레임워크 없이 개발하는 것이 불가능해진다.

## Spring Framework
+ 자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크
+ 자바개발을 위한 프레임워크로 종속 객체를 생성해주고, 조립해주는 도구
+ 자바로 된 프레임워크로 자바SE로 된 자바 객체(POJO)를 자바EE에 의존적이지 않게 연결해주는 역할

### Java SE, Java EE, POJO
+ Java SE(Standard Edition)
  + 가장 보편적으로 쓰이는 자바 API집합체(패키지)이다.
+ Java EE(Enterprise Edition)
  + Java SE 스펙 기반으로 자바를 이용한 서버측 개발을 위한 플랫폼이다.
  + 엔터프라이즈 환경을 위한 도구로 EJB, JSP, Servlet, JNDI 등을 지원하며 애플리케이션 개발에 주로 사용된다.
+ POJO(Plain Old Java Object)
  + 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트
  + 예전에 원하는 엔터프라이즈 기술이 있다면 그 기술을 직접적으로 사용하는 객체를 설계하였다.
  + 특정 기술과 환경에 종속되어 의존하게 된 자바코드는 가독성이 떨어져 유지보수에 어려움이 생긴다.
  + 또한, 특정 기술의 클래스를 상속받거나, 직접 의존하게 되어 확장성이 매우 떨어진다.
  + 이것은 자바가 객체지향 설계의 장점을 잃어버리게 되는 것이다.
  + 그래서 본래 자바의 장점을 살리는 **오래된 방식의 순수한 자바객체** 라는 개념을 지닌 POJO가 등장했다.

### 스프링 특징
+ 경량
  + 개발에서 프레임 워크를 사용하는 데 약간의 오버헤드가 있습니다.
+ IoC(Inversion of Control)
  + Spring 컨테이너는 종속 개체를 생성하거나 찾는 대신 다양한 개체의 연결 의존성을 처리합니다.
+ AOP(Aspect Oriented Programming)
  + Spring은 시스템 서비스에서 비즈니스 로직을 분리하기 위해 AOP를 지원합니다.
+ IoC 컨테이너
  + Spring Bean 라이프 사이클 및 프로젝트 별 구성을 관리합니다.
+ MVC 프레임 워크
  + XML / JSON 응답을 반환 할 수 있는 웹 애플리케이션 또는 RESTful 웹 서비스를 만드는 데 사용됩니다.
+ 트랜잭션 관리
  + Java 어노테이션을 사용하여 JDBC 작업, 파일 업로드 등에서 상용구 코드의 양을 줄입니다.
+ 예외처리
  + Spring은 기술 별 예외를 확인되지 않은 예외로 변환하기 위한 편리한 API를 제공합니다.

## PSA(Portable Service Abstraction)
+ 추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이 서비스 추상화(Service Abstraction)
+ 하나의 추상화로 여러 서비스를 묶어둔 것을 PSA(Portable Service Abstraction) 

## IoC(Inversion of Control)
+ 메소드나 객체의 호출 작업을 개발자가 결정하는 것이 아니라, 외부에서 결정되는 것
+ 객체의 의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드를 작성할 수 있게 하여 가독성 및 코드 중복, 유지 보수를 편하게 할 수 있다.
+ 제어의 흐름을 사용자가 컨트롤 하는 것이 아니라 스프링에게 맡겨 작업을 처리

### IoC 컨테이너
+ 컨테이너 : 객체의 생명주기를 관리, 생성된 인스턴스들에게 추가적인 기능을 제공하도록 하는 것
+ IoC 컨테이너 : 객체를 생성하고 관리하고 책임지고 의존성을 관리해주는 컨테이너
+ 컨테이너 종류
  + BeanFactory
    + 단순히 컨테이너에서 객체를 생성하고 DI를 처리하는 기능만 제공한다.
    + Bean을 등록, 생성, 조회, 반환 관리를 한다.
    + 팩토리 디자인 패턴을 구현한 것으로 BeanFactory는 빈을 생성하고 분해하는 책임을 지는 클래스이다.
    + Bean을 조회할 수 있는 getBean() 메소드가 정의되어 있다.
    + 보통은 BeanFactory를 바로 사용하지 않고, 이를 확장한 ApplicationContext를 사용한다.
  + ApplicationContext
    + Bean을 등록, 생성, 조회, 반환 관리하는 기능은 BeanFactory와 같다.
    + 국제화가 지원되는 텍스트 메세지를 관리
    + 이미지같은 파일 지원을 로드할 수 있는 포괄적인 방법을 제공
    + 리스너로 등록된 빈에게 이벤트를 발생

## DI(Dependency Injection)
+ 객체를 직접 생성하는 게(new) 아니라 외부(IoC 컨테이너)에서 생성한 후 주입 시켜주는 방식(setter, 생성자)
+ DI를 통해서 모듈 간의 결합도가 낮아지고 유연성이 높아진다.

## Bean 태그의 Scope 범위
+ singleton : Spring Container에 한개의 빈 객체만 존재 - 기본 값
+ prototype : 빈을 사용할 때 마다 빈 객체를 생성한다.
+ request : HTTP요청마다 빈 객체를 생성한다.
+ session : HTTP세션마다 빈 객체를 생성한다.

## Spring MVC 구조의 처리과정
![스프링1](https://user-images.githubusercontent.com/48073115/127432457-0c5c6582-c77d-4500-8e43-71d915605f17.png)

### DispatcherServlet
+ 애플리케이션으로 들어오는 모든 Request 를 받는 관문
+ Request 를 실제 처리할 Controller 에게 전달하고 그 결과값을 받아서 View 에게 전달하여 적절한 응답을 생성할 수 있도록 흐름을 제어한다.

### HandlerMapping
+ Request URL 각각 어떤 Controller가 실제 처리할 것 인지 찾아주는 역할

### Controller
+ Request 를 직접 처리한 후 그 결과를 다시 DispatcherServlet에게 돌려준다.

### ModelAndView
+ Controller가 처리한 결과와 그 결과를 보여줄 View에 관한 정보를 담고 있는 객체이다.

### ViewResolver
+ View 관련 정보를 갖고 실제 View 를 찾아주는 역할을 한다.

### View
+ Controller가 처리한 결과값을 보여줄 View를 생성한다.

## VO DTO
+ VO : 사용 되는 값이 객체로 표현되며, 값 변경이 없는 경우를 말한다.
+ DTO : 데이터의 전송을 위한 객체이며, 비지니스 로직까지 담아서 사용한다.

## Spring boot
+ 내부에 톰켓 설치
  + 따로 톰켓을 설치하거나 매번 버전을 관리해 주어야 하는 수고로움을 덜어준다.
+ starter을 통한 dependency 자동화

## Spring Annotation
+ @을 이용한 주석, 자바 코드에 주석을 달아 특별한 의미를 부여한 것
+ @Override 어노테이션처럼 컴파일러를 위한 정보를 제공하기 위한 용도이다.
+ 스프링 프레임워크의 @Controller 어노테이션처럼 런타임에 리플렉션을 이용해서 특수 기능을 추가하기 위한 용도
+ 컴파일 과정에 어노테이션 정보로부터 코드를 생성하기 위한 용도

+ 자바 리플렉션
  + 다른 언어에서는 존재하지 않는 특별한 기능
  + 컴파일 시간이 아닌 실행시간에 동적으로 특정 클래스의 정보를 객체를 통해 분석 및 추출해내는 프로그래밍 기법

## Spring Security 요청 과정
### 인증(Authentication) -> 인증 성공 후 -> 인가(Authorization)
+ 기본적으로 인증 절차를 거친 후에 인가 절차를 진행하게 되며, 인가 과정에서 해당 리소스에 대한 접근 권한이 있는지를 확인
+ 인증과 인가를 위해 Principal을 아이디로, Credentical을 비밀번호로 사용하는 인증방식을 사용합니다.
+ 기본적으로 인증 정보는 최종적으로 인메모리 세션 저장소인 SecurityContextHolder에 세션 - 쿠키 방식으로 저장됩니다.

+ 인증(Authentication) : 해당 사용자가 본인이 맞는지를 확인하는 절차
+ 인가(Authorization) : 인증된 사용자가 요청한 자원에 접근 가능한지를 결정하는 절차
+ 접근 주체(Principal) : 보호받는 Resource에 접근하는 대상
+ 비밀번호(Credential) : Resource 에 접근하는 대상의 비밀번호
+ 권한 : 인증된 주체가 어플리케이션의 동작을 수행할 수 있도록 허락되어 있는지 결정
  + 인증 과정을 통해 주체가 증명된 이후 권한을 부여 할 수 있다.
  + 권한 부여에 두 가지 영역이 존재하는데, 웹 요청 권한과 메서드 호출 및 도메인 인스턴스에 대한 접근 권한 부여가 있다.

### Spring Security 동작 과정

![0](https://user-images.githubusercontent.com/48073115/148367246-b42d3d89-fc07-4774-871b-1b8ab1bc76fd.png)

+ 1. 과정
  + 사용자가 Form을 통해 로그인 정보를 입력하고 인증 요청을 보낸다.
+ 2. 과정
  + AuthenticationFilter(UsernamePasswordAuthenticationFilter)가 HttpServlet Request에서 사용자가 보낸 아이디와 패스워드를 인터셉트한다
  + 안전을 위해서 다시 한번 사용자가 보낸 아이디와 패스워드의 유효성 검사를 한다.
  + HttpServletRequest에서 꺼내온 사용자 아이디와 패스워드를 진짜 인증을 담당할 AuthenticationManager 인터페이스(구현체 - ProviderManager)에게 인증용 객체(UsernamePasswordAuthenticationToken)로 만들어줘서 위임한다.
+ 3. 과정 
  + AuthenticationFilter에게 인증용 객체(UsernamePasswordAuthenticationToken)을 전달받는다.
+ 4. 과정
  + 실제 인증을 할 AuthenticationProvider에게 Authentication객체(UsernamePasswordAuthenticationToken)을 다시 전달한다.
+ 5. 과정
  + DB에서 사용자 인증 정보를 가져올 UserDetailsService 객체에게 사용자 아이디를 넘겨준다.
  + DB에서 인증에 사용할 사용자 정보를 UserDetails 객체로 전달받는다.
+ 6. 과정
  + AuthenticationProvider는 UserDetails 객체를 전달 받은 이후 실제 사용자의 입력 정보와 UserDetails 객체를 가지고 인증을 시도한다.
+ 7, 8, 9, 10. 과정
  + 인증이 완료되면 사용자 정보를 가진 Authentication 객체를 SecurityContextHolder에 담은 이후 AuthenticationSuccessHandle를 실행한다.
  + 실패시 AuthenticationFailureHandler를 실행한다.

## JPA
### JPA 와 Hibernate
+ JPA는 Java 진영의 ORM 기술 표준으로 java에서 ORM을 어떻게 사용해야 하는지 정의해 놓은 인터페이스
+ 인터페이스이기에 이를 구현한 구현체가 필수로 필요하다.
+ Hibernate는 JPA를 구현한 구현체로 가장 많이 쓰이는 JPA 구현체이다.
+ Spring Data JPA는 JPA 편하게 쓰라고 스프링에서 제공하는 모듈

#### ORM(Object-relational Mapping)
+ 객체관계 매핑
+ 객체는 객체대로 설계, 관계형데이터베이스는 관계형데이터베이스대로 설계
+ ORM프레임워크가 이 둘을 중간에서 매핑, ORM이 내부적으로 JDBC를 사용해서 적절한 SQL을 자동으로 생성해서 진행하기 때문에 별도의 SQL을 작성할 필요가 없다. 물론 복잡한 SQL은 직접 작성해야 한다.

### 영속성 컨텍스트
+ 엔티티를 영구 저장하는 환경
+ 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스
+ 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

#### 장점
+ **1차 캐시**
  + 영속성 컨텍스트 내부에 캐시가 있는데 이를 1차 캐시라고 한다.
  + 영속 상태의 엔티티를 이곳에 저장한다.
  + 1차 캐시의 키는 식별자 값(데이터베이스의 기본 키)이고 값은 엔티티 인스턴스이다.
  + 조회의 흐름
    1. 1차 캐시에서 엔티티를 찾는다.
    2. 있으면 메모리에 있는 1차 캐시에서 엔티티를 조회한다.
    3. 없으면 데이터베이스에서 조회한다.
    4. 조회한 데이터로 엔티티를 생성해 1차 캐시에 저장한다.(엔티티를 영속상태로 만든다)
    5. 조회한 엔티티를 반환한다.
+ **영속 엔티티의 동일성 보장**
  + 영속성 컨텍스트는 엔티티의 동일성을 보장한다.
+ **트랜잭션을 지원하는 쓰기 지연**
  + em.find(member)를 사용해 member를 저장해도 바로 INSERT SQL이 DB에 보내지는 것이 아니다.
  + 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL을 모아둔다.
  + 트랜잭션을 커밋할 때 모아둔 쿼리를 DB에 보낸다.
+ **변경 감지**
  + JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터를 변경하면 된다.
  + 변경감지의 흐름
    1. 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다.
    2. 엔티티와 스냅샷을 비교하여 변경된 엔티티를 찾는다.
    3. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 저장한다.
    4. 쓰기 지연 저장소의 SQL을 플러시한다.
    5. 데이터베이스 트랜잭션을 커밋한다.
  + 변경감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티만 적용된다.

#### 플러시
+ 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.
+ 영속성 컨텍스트의 엔티티를 지우는게 아니라 변경 내용을 데이터베이스에 동기화하는 것이다.
+ 플러시의 흐름
  1. 변경 감지가 동작해서 스냅샷과 비교해서 수정된 엔티티를 찾는다.
  2. 수정된 엔티티에 대해서 수정 쿼리를 만들고 SQL 저장소에 등록한다.
  3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.

#### 스냅샷
+ 과거의 한 때 존재하고 유지시킨 컴퓨터 파일과 디렉터리의 모임

### Eager, Lazy Loading
+ 즉시 로딩(Eager Loading)
  + 특정 엔티티를 조회할 때 연관된 모든 엔티티를 같이 로딩하는 것
  + 엔티티간의 관계가 복잡해질수록 불필요한 조인까지 포함해서 처리하는 경우가 많기 때문에 성능저하를 피할 수 없다.
  + 장점
    + 지연된 초기화와 관련해서 성능적인 영향이 없음
  + 단점
    + 지연 로딩보다 긴 초기의 로딩 시간이 필요함
    + 불필요한 데이터를 많이 로딩하면 성능에 영향을 줄 수 있음
+ 지연 로딩(Lazy Loading)
  + 가능한 객체의 초기화를 지연시키는데 사용하는 패턴
  + 장점
    + 다른 접근 방식보다 훨씬 적은 초기의 로딩 시간
    + 다른 접근 방식보다 메모리 소비량 감소
  + 단점
    + 초기화가 지연되면 원하지 않는 순간 성능에 영향을 줄 수 있음

### n+1 문제
#### 원인
+ JPQL이라는 객체지향 쿼리 언어를 생성, 실행시킨 후 JPA는 이것을 분석해서 SQL을 생성, 실행하는 동작에서 N+1 문제가 발생한다.
+ N+1 발생하는 경우
  + 즉시 로딩으로 데이터를 가져오는 경우
  + 지연 로딩으로 데이터를 가져온 이후에 가져온 데이터에서 하위 엔티티를 다시 조회하는 경우

#### 하위 엔티티를 조회하는 경우
+ 지연 로딩을 하기 위해서는 해당 엔티티가 영속 상태여야 한다.
+ 보통 Repository에서 리스트로 가져오면 영속이 끊긴 상태로 가져오기 때문에 지연 로딩 테스트시 @Transactional을 꼭 사용해야 한다.

#### 해결 방법
+ 패치 조인(Fecth Join)
  + 미리 하위 엔티티 데이터를 조인해서 가져온다.
  + 단점
    + JPA가 제공하는 Pageable 기능 사용 불가
    + 1:N 관계가 2개인 엔티티를 패치 조인 사용 불가
+ Batch Size 조절
  + 설정한 Size만큼 데이터를 미리 로딩한다.
  + JPA의 페이징 API 기능처럼 개수가 고정된 데이터를 가져올 때 함깨 사용하면 유용하게 사용 가능
  + 글로벌 패치 전략을 즉시 로딩으로 변경해야하는 단점 존재

### 다대다 해결 전략
+ 다대다를 지원하는 @ManyToMany 어노테이션을 제공하지만 지양해야한다.
  + 중간 테이블을 생성해주긴 하지만 묵시적으로 생성해주기 때문에 자기도 모르는 복잡한 조인의 쿼리가 발생하는 경우가 생길 수 있다.
  + 중간 테이블에 두 테이블의 기본키를 기본키이자 외래키로 들고와서 추가로 필요한 컬럼이 존재할 확률이 크지만, 중간 테이블에 필요한 추가 컬럼을 사용할 수 없다.(두 테이블에 추가된 컬럼에 대해 매핑이 되지 않기 때문이다.)
+ 다대다 관계를 일대다, 다대일 관계로 풀어 직접 사용하는 것이 좋다.

### JPA 캐시
+ 네트워크를 통한 데이터베이스를 접근하는 시간과 한번 조회된 데이터를 애플리케이션 서버에서 내부 메모리에 접근하는 시간의 비용의 차이는 수십만 배 비싸다. 따라서 캐시를 통해 데이터베이스 접근 횟수를 줄여 성능을 획기적으로 개선할 수 있다.

#### 1차 캐시
+ 1차 캐시는 영속성 콘텍스트 내부에 엔티티를 보관하는 저장소가 존재한다.
+ 1차 캐시는 트랜잭션을 시작하고 종료할 때까지만 1차캐시가 유효하다.
+ OSIV를 사용해도 결국 클라이언트 요청이 들어올 때 부터 끝날 때 까지만 1차 캐시가 유효하다.
+ 동작방식
  + 사용자의 요청이 들어오면 OSIV를 적용하지 않았다고 가정할 때 트랜잭션 범위안에서 엔티티의 조회 요청이 들어온다.
  + 엔티티 매니저는 해당 엔티티를 데이터베이스를 통해 조회하며 자신의 영속성 콘텍스트에 저장한다. 그리고 해당 엔티티를 반환해준다.
  + 동일 트랜잭션 범위 내에서 같은 엔티티의 조회 요청이 들어온다면 1차 캐시에 저장된 엔티티를 반환해준다.

#### 2차 캐시
+ 2차 캐시는 Hibernate를 포함한 대부분의 JPA 구현체들은 애플리케이션 범위의 캐시를 지원한다.
+ 동작방식
  + 엔티티 매니저는 최초 조회를 2차 캐시에 한다. 2차 캐시에 존재하지 않는다면 db에 조회를 한다.
  + 조회의 결과 값을 2차 캐시에 저장하고 해당 엔티티의 복사본을 1차 캐시인 영속성 컨텍스트에 반환해준다.
  + 동일 조회가 다른 영속성 컨텍스트에 들어온다면 2차 캐시에 존재하는 엔티티를 복사하여 전달해 준다.

#### OSIV
+ 영속성 컨텍스트의 생존 범위
+ OSIV ON
  + 커넥션 시작부터 API 응답이 끝날 때 까지 영속성 컨텍스트가 유지된다.
  + Controller에서도 지연 로딩을 사용할 수 있다.
  + DB커넥션을 오랫동안 사용하기 때문에 실시간 트래픽이 몰리면 커넥션이 모자랄 수 있다.
+ OSIV OFF
  + 트랜잭션이 종료될 때 영속성 컨텍스트를 닫고 DB커넥션도 반환한다. 따라서 커넥션 리소스를 낭비하지 않는다.
  + 모든 지연로딩을 트랜잭션 안에서 처리해야 한다.

출처 - [기술면접 - Spring framework](https://sas-study.tistory.com/58?category=774876)

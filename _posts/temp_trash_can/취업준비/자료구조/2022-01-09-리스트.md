[//]: # (---)

[//]: # (title: "List")

[//]: # (categories: JP_dataStructure)

[//]: # (---)

[//]: # ()
[//]: # ([1. Array, LinkedList 차이]&#40;#Array-LinkedList-차이&#41;  )

[//]: # ([2. Array, ArrayList 차이]&#40;#Array-ArrayList-차이&#41;)

[//]: # ()
[//]: # (## Array, LinkedList 차이)

[//]: # (### 접근)

[//]: # (+ Array)

[//]: # (  + Random Access를 지원한다.)

[//]: # (  + 요소들을 인덱스를 통해 직접 접근할 수 있다.)

[//]: # (  + 특정 요소에 접근하는 시간복잡도는 O&#40;1&#41;이다.)

[//]: # (+ LinkedList)

[//]: # (  + Sequential Access를 지원한다.)

[//]: # (  + 어떤 요소를 접근할 때 순차적으로 검색하며 찾아야한다.)

[//]: # (  + 특정 요소에 접근하는 시간복잡도는 O&#40;n&#41;이다.)

[//]: # (  )
[//]: # (+ Random Access : 원소 그룹 내의 요소의 주소를 알면 어느 부분에서도 즉시 데이터에 접근할 수 있는 방식)

[//]: # (+ Sequential Access : 순서가 정해진 원소 그룹을 순차적으로 접근하는 방식)

[//]: # ()
[//]: # (### 삽입과 삭제)

[//]: # (+ Array)

[//]: # (  + 요소들은 인접한 메모리 위치에 연이어 저장한다.)

[//]: # (  + 삽입과 삭제에서 시간복잡도는 O&#40;n&#41;이다)

[//]: # (+ LinkedList)

[//]: # (  + 새로운 요소에 할당된 메모리 위치 주소가 LinkedList의 이전 요소의 node에 저장된다.)

[//]: # (  + 삽입과 삭제에서 시간복잡도는 O&#40;1&#41;이다)

[//]: # ()
[//]: # (### 메모리 할당)

[//]: # (+ Array)

[//]: # (  + 선언 시 컴파일 타임에 할당이 된다.&#40;정적 메모리 할당&#41;)

[//]: # (  + Stack 섹션에 메모리 할당이 이루어 진다.)

[//]: # (+ LinkedList)

[//]: # (  + 새로운 요소가 추가될 때 런타임에 메모리를 할당한다.&#40;동적 메모리 할당&#41;)

[//]: # (  + Heap 섹션에 메모리 할당이 이루어 진다.)

[//]: # ()
[//]: # (## Array, ArrayList 차이)

[//]: # (||Array|ArrayList|)

[//]: # (|:-:|:-:|:-:|)

[//]: # (|사이즈|초기화시 고정|초기화시 사이즈를 표시하지 않음. 사이즈가 동적이다.|)

[//]: # (|속도|초기화시 메모리에 할당되어 속도 빠름|추가시 메모리를 재할당하여 속도가 느림|)

[//]: # (|변경|사이즈 변경 불가|추가, 삭제 가능|)

[//]: # (|다차원|가능|불가능|)

[//]: # (|타입|primitive type, object|object element만 가능|)

[//]: # (|제네릭|사용 불가능|사용 가능&#40;타입 안전성 보장&#41;|)

[//]: # (|길이|length 변수|size&#40;&#41; 메소드|)

[//]: # (|변수 추가|assignment 연산자 사용|add&#40;&#41; 메소드 사용|)

[//]: # ()
[//]: # (+ Array와 ArrayList는 모든 것이 비슷하다.)

[//]: # (+ 가장 큰 차이점은 길이 조정 여부입니다.)

[//]: # (+ Array가 ArrayList보다 빠릅니다.)

[//]: # ()
[//]: # (### Resizeable)

[//]: # (+ Array는 생성한 후에는 길이가 고정되어 있습니다.)

[//]: # (+ ArrayList는 size를 나타내는 capacity 인스턴스 변수를 가지고 있다. 만약 설정한 capacity를 넘어서 더 많은 객체가 들어오면, 일반적으로 기존의 용량 + 기존 용량/2 만큼 크기가 늘어난 배열에 기존의 배열을 copy해준다.)

[//]: # ()
[//]: # (### Type-Safety)

[//]: # (+ Array)

[//]: # (  + Array는 homogeneous&#40;동종&#41; data structure이다.)

[//]: # (  + 특정 데이터 타입의 primitive나 특정 클래스의 object만을 저장할 수 있다.)

[//]: # (  + 만약 명시된 타입이 아닌 다른 데이터 유형을 Array에 저장할 경우 ArrayStoreException이 발생한다.)

[//]: # (```java)

[//]: # (String temp[] = new String[2];  // create a string array of size 2)

[//]: # (temp[0] = new Integer&#40;12&#41;;      // throw ArrayStoreException)

[//]: # (+ ArrayList)

[//]: # (  + Generics&#40;제네릭스&#41;를 통해 Type-Safety를 보장한다.)

[//]: # (  )
[//]: # (### Multi-dimensional)

[//]: # (+ Array : 다차원이 가능하다.)

[//]: # (```java)

[//]: # (int addarrayobject[][] = new int[3][2];)

[//]: # (```)

[//]: # (+ ArrayList : 항상 단일 차원이다.)

[//]: # ()
[//]: # (#### Generics)

[//]: # (+ <>안에 어떠한 타입을 선언해주어 사용할 객체의 타입을 지정해준다.)

[//]: # (+ 다룰 객체의 타입을 미리 명시하여 객체의 형변환을 사용할 필요없게 하며, 내가 사용하고 싶은 데이터 타입만 사용할 수 있게 해주는 효과)

[//]: # (+ 장점)

[//]: # (  + 의도하지 않은 타입의 객체가 저장되는 것을 막고, 다른 타입의 객체로 인한 타입 형태가 맞지 않아 발생하는 문제를 없애준다.)

[//]: # (  + 타입을 미리 명시함으로써 다른 타입의 객체가 저장되지 않아 객체를 꺼내 사용할 시 형변환을 통한 타입을 맞출 필요가 없어 코드를 간결하게 줄일 수 있다.)

[//]: # (  )

---
title: "네트워크"
categories: JP_TI
---

중요  
[1. OSI 7계층](#OSI-7-Layer)  
[2. TCP:Handshake, UDP, 흐름제어, 혼잡제어](#TCP-UDP)  
[3. http https](#HTTP-HTTPS-프로토콜)  
[4. 쿠키, 세션](#쿠키-세션)  
[5. 게이트웨이](#게이트웨이)  
[6. DNS](#DNS)  
[7. 프록시](#프록시)  
[8. CORS](#CORS)  
[9. JWT](#JWT)  

## 네트워크
+ 물리적 전송 매체를 사용하여 서로 연결된 장치 세트
+ 컴퓨터 네트워크는 하드웨어, 데이터 및 소프트웨어와 같은 정보 및 리소스를 통신하고 공유하기 위해 서로 연결된 컴퓨터 그룹
+ 네트워크에서 노드는 둘 이상의 네트워크를 연결하는 데 사용됨

### 네트워크 망의 종류
+ LAN
  + 한 건물 또는 사무실 내의 호스트들 간에 연결된 소규모 네트워크
+ MAN
  + LAN과 LAN을 연결하는 중규모 네트워크
+ WAN
  + MAN과 MAN을 연결하는 대규모 네트워크

## Cast
+ Unicast
  + 1:1 통신, 원하는 대상 하나를 정해서 통신
+ Multicast
  + 1:N 통신, 원하는 대상 여러 명을 정해서 통신
+ Broadcast
  + 1:all 통신, 내 의지와 상관없이 무조건 받아들여야 하는 통신

## 회선, 대역폭
+ 전송되는 데이터를 허용할 수 있는 동시 접속자 수

## ISP(Internet Service Provider)
+ 인터넷 서비스 공급자로 다양한 회선 상품을 제공하며 기업마다 서비스가 다름

## VPN(Virtual Private Network)
+ 가설시설망으로 ISP에 정보를 넘겨주지 않고 익명성을 유지하여 인터넷에 접속

## FTTH(Fiber To The Home)
+ 광통신, 초고속 기가 인터넷, 집안까지 광케이블을 통해 인터넷을 제공하는 서비스

## IP(Internet Protocol Address)
+ 컴퓨터 네트워크에서 기기들이 서로를 인식하고 통신하기 위해 사용하는 식별번호

## 패킷
+ 네트워크 상에서 전송하는 데이터를 일정한 크기로 잘라 작게 나눠진 데이터의 묶음 -> 안전성 때문에 나눠서 보냄
+ 큰 데이터는 대역폭을 너무 많이 차지하기 때문에 패킷의 흐름을 원할하게 하지못한다. -> 트래픽이 많아짐
+ 누구에게 어디로 무엇을 보내야 하는지에 대한 정보가 담겨있다

### 대역폭
+ 신호를 전송할 수 있는 주파수 범위 또는 폭

### 트래픽
+ 통신망을 통과하는 정보의 흐름, 통신망과 통신 기기를 점유하는 시간으로 그 양을 나타냄.

## TCP/IP 프로토콜 4계층
+ LINK 계층
  + 물리적인 계층, LAN, MAN, WAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역
+ IP 계층
  + 데이터 경로 설정, 특별한 규칙 없음, 오류 발생하면 다른 임의의 경로로 변경
+ TCP/UDP(전송) 계층
  + 데이터의 실제 송수신, IP 계층에서 발생한 문제를 해결
+ APPLICATION 계층
  + 서버와 클라이언트를 만드는 과정에서 프로그램의 성격에 따라 정한 데이터 송수신에 대한 약속(규칙)

### 네트워크 애플리케이션 역할
+ TCP/IP
  + 소프트웨어에 데이터를 전달할 때, 데이터를 받을 호스트의 주소인 IP 주소와 포트번호도 함께 전달
+ IP 주소
  + 네트워크에 연결된 기기를 식별하는 유일한 번호
+ 포트 번호
  + 수신 측에서 동작하는 여러 애플리케이션 중 데이터를 수신할 애플리케이션을 식별하는 번호

## TCP, UDP
### TCP
+ 연결지향형 전송 규약
+ 흐름 중심 프로토콜, 통신을 주고 받는 것을 중요시함
+ 중간에 패킷이 손실되는 경우 재전송(TCP 3-way handshake)을 통해 신뢰성을 보장함(느림)
+ 대부분의 통신에서 사용됨, 특히 파일이나 데이터 전송 시에 사용
+ 데이터 경계 구분이 없음 (바이트 스트림 서비스)

### UDP
+ 비연결지향형 전송 규약
+ 데이터 중심 프로토콜, 데이터를 일방적으로 보내는 것을 중요시함
+ 데이터 전송의 신뢰성을 보장 안함(빠름)
+ P2P, 스트리밍, 전화에 사용

### 바이트 스트림 서비스
+ 한번에 한 바이트씩 연속적으로 전송되는 데이터의 흐름과 같이 끊임없이 연속되는 바이트 열.

## 3-Handshake, 4-Handshake
### 3-Handshake
![네트워크1](https://user-images.githubusercontent.com/48073115/127558949-05e26b5a-05fa-4aff-acda-7576bfc06ada.png)

+ 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 한다.
+ 양쪽 모두 상대편에 대한 초기 순차일련번호를 얻을 수 있도록 한다.
+ TCP의 3-way Handshaking 과정
  + **STEP1**
    + A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다.
    + 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태, B서버는 Wait for Client 상태이다.
  + **STEP2**
    + B서버는 SYN 요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송한다.
    + B서버는 A클라이언트가 다시 ACK 으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.
  + **STEP3**
    + A클라이언트는 B서버에게 ACK 를 보내고 이후로부터 연결이 이루어지고 데이터가 오가게 된다.
    + 이때 B서버 상태는 ESTABLISHED 이다.

### 4-way Handshaking
![네트워크2](https://user-images.githubusercontent.com/48073115/127566158-b1bd861c-f4e9-443b-b20f-fc505d33b29f.png)

+ 3-way Handshake 는 TCP의 연결을 초기화 할 때 사용한다.
+ 4-way Handshake 는 세션을 종료하기 위해 수행되는 절차이다.
+ TCP의 4-way Handshaking 과정
  + **STEP1**
    + 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다.
    + 이때 A클라이언트는 FIN-WAIT 상태가 된다.
  + **STEP2**
    + B서버는 FIN 플래그를 받고, 일단 확인메시지 ACK 보내고 자신의 통신이 끝날때까지 기다린다.
    + 이때 B서버는 CLOSE-WAIT 상태가 된다.
  + **STEP3**
    + 연결을 종료할 준비가 되면, 연결해지를 위한 준비가 되었음을 알리기 위해 클라이언트에게 FIN플래그를 전송한다.
    + 이때 B서버는 LAST-ACK 상태가 된다.
  + **STEP4**
    + A클라이언트는 해지준비가 되었다는 ACK를 확인했다는 메시지를 보낸다.
    + A클라이언트 상태가 FIN-WAIT -> TIME-WAIT 로 변경된다.

### TIME-WAIT
+ 클라이언트는 서버에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN패킷보다 늦게 도착하는 상황이 발생한다면 그 패킷은 Drop 되고 데이터는 유실될 것이다.
+ 클라이언트는 이러한 현상에 대비하여 클라이언트는 서버로부터 FIN을 수신하더라도 일정시간동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 **TIME-WAIT** 라고 한다.
+ 일정시간이 지나면, 세션을 만료하고 연결을 종료시키며 **CLOSE** 상태로 변화한다.

### 흐름제어(Flow Control)
+ 송신측과 수신측의 데이터처리 속도 차이를 해결하기 위한 기법
+ 송신측이 수신측보다 속도가 빠르면 문제가 발생한다.
+ 송신측이 수신축보다 속도가 빠르면 수신측에서 제한된 저장용량(일반적으로 큐)을 초과하여 이후에 도착하는 데이터의 손실을 가져올 수 있다.
+ 데이터가 손실되면 불필요하게 응답과 재전송의 데이터가 다시 송신측과 수신측간에 번번히 이동해야한다.
+ 이러한 위험을 줄이기 위해 강제로 송신측의 데이터 전송을 줄인다.
+ 기법
  + Stop and wait 기법
    + 매번 전송한 패킷에 대해 확인응답을 받아야만 그 다음 패킷을 전송하는 방법
  + 슬라이딩 윈도우 기법
    + 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하여 제어하는 기법

### 혼잡제어(Congestion control)
+ 송신측의 데이터 전달과 네트워크의 처리속도 차이를 해결하기 위한 기법
+ 한 라우터에 데이터가 몰릴 경우 라우터는 자신에게 온 데이터를 모두 처리할 수 없다.
+ 그렇게 되면 호스트들은 또 다시 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실을 발생시킨다.
+ 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 강제로 줄인다.
+ 기법
  + Slow start 기법
    + 윈도우 크기를 2배 늘린다.
    + 그러다 혼잡현상이 발생하면 창 크기를 1로 떨어뜨린다.
    + 그 후 혼잡현상이 발생했던 창 크기의 절반까지는 이전처럼 지수 함수 꼴로(2배로) 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.
  + Fast Recovery 기법
    + 혼잡한 상태가 되면 창 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 

## OSI 7 Layer
+ 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것을 말한다.
+ OSI 7 Layer을 나눈 이유는?
  + 계층을 분리함으로서 각 계층은 독립적인 역할을 할 수 있다.
  + 역할이 분리되면서 문제 발생시 문제의 현상을 보았을 때 어떤 계층에 문제가 생겼는지 파악이 가능해 다른 단계의 장비 및 소프트웨어를 건들지 않고도 이상이 생긴 단계만 고칠 수 있다.
  + 각 계층은 하위계층을 사용하고 현계층의 기능을 포함하여 상위 계층에 제공한다. 따라서 상위 계층은 하위 계층을 모두 포함하고 있다.

![네트워크3](https://user-images.githubusercontent.com/48073115/127572097-544828b9-480f-4e50-89ea-9d63f6b81e97.png)

+ 물리계층(Physical Layer)
  + 하드웨어 전송 기술로 이루어져 있다.
  + 전기적인, 기계적인 신호를 주고받는 역할을 하는 계층이다. 비트 0, 1의 통신단위로 통신한다.
  + 대표적인 장비는 통신 케이블, 허브, 리피터 등이 있다.
  + 데이터의 종류나 오류를 제어하지 않는다.
+ 데이터 링크 계층(Data Link Layer)
  + Point to Point 간의 신뢰성 있는 전송을 보장하기 위한 계층이다.
  + 전송 데이터에 대한 CRC 오류제어가 필요하다.
  + 대표적인 장비는 스위치와 브릿지가 있다.
  + 물리주소인 MAC주소가 이 계층에 해당한다.
  + 전송 단위는 Frame 이다.
+ 네트워크 계층(Network Layer)
  + IP주소를 제공하는 계층이다.
  + 노드들을 거칠때마다 라우팅 해주는 역할을 담당한다.
  + 이 계층의 대표적인 장비는 라우터, L3 스위치, IP 공유기 등이 있다.
  + 전송 단위는 Packet이다.
+ 전송 계층(Transport Layer)
  + End to End의 사용자들이 데이터를 주고 받을 수 있게 하는 계층이다.
  + 대표적으로 우리가 자주 사용하는 TCP, UDP 프로토콜이 있는 계층이다.
  + 전송 단위는 Segment 이다.
+ 세션 계층(Session Layer)
  + 세션 계층부터 데이터를 만들어내는 계층이다. 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
  + 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다.
  + 이 계층은 TCP/IP 세션을 만들고 없애는 책임을 진다.
  + 통신하는 사용자들을 동기화하고 오류복구 명령들을 일괄적으로 다룬다.
  + 대표적으로 RPC, Socket 등이 있다.
+ 표현 계층(Presentation Layer)
  + 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다.
  + MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.
  + 우리가 자주 사용하는 데이터 압축이나 인코딩 등을 여기에서 다룬다.
+ 응용 계층(Application Layer)
  + 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.
  + 한마디로 우리가 사용하는 사용자 인터페이스를 제공하는 프로그램 등을 말한다.
  + 대표적으로 HTTP, FTP 등의 프로토콜이 응용 계층에 속한다.

## 허브, 리피터
<table>
  <thead>
    <tr>
      <th></th>
      <th width="40%">리피터</th>
      <th width="40%">허브</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>공통점</td>
      <td colspan="2"> 물리계층에서 전기적인 신호를 증폭시켜 전송거리를 연장하는 장치<br>
        네트워크 신호가 연결된 모든 PC에 전달되기 때문에 연결된 장치가 많을수록 부하가 심해짐</td>
    </tr>
    <tr>
      <td>차이점</td>
      <td></td>
      <td>패킷 모니터링과 멀티 포트를 지원하며 문제가 생긴 곳을 고립시킬 수 있음</td>
    </tr>
  </tbody>
</table>

## 브릿지, 스위치
<table>
  <thead>
    <tr>
      <th></th>
      <th width="40%">브릿지</th>
      <th width="40%">스위치</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>공통점</td>
      <td colspan="2"> 데이터링크 계층에서 전송 거리를 연장하는 장치</td>
    </tr>
    <tr>
      <td>차이점</td>
      <td>IP 주소에서 MAC 주소를 알아냄</td>
      <td>MAC 주소에서 IP 주소를 알아냄</td>
    </tr>
  </tbody>
</table>

## ARP, RARP
<table>
  <thead>
    <th></th>
    <th width="40%">ARP</th>
    <th width="40%">RARP</th>
  </thead>
  <tbody>
    <tr>
      <td>공통점</td>
      <td colspan="2"> 네트워크 계층에서 사용되는 주소 결정 프로토콜</td>
    </tr>
    <tr>
      <td>차이점</td>
      <td>IP 주소에서 MAC 주소를 알아냄</td>
      <td>MAC 주소에서 IP 주소를 알아냄</td>
    </tr>
  </tbody>
</table>

## 게이트웨이
+ 외부로 연결되는 통로, 로컬망 라우터와 외부망 라우터 간의 통로

### 라우터
+ 컴퓨터 네트워크 간에 데이터 패킷을 전송하는 네트워크 장치

## DNS
+ www.example.com과 같이 사람이 읽을 수 있는 이름을 192.0.2.1과 같은 숫자 IP 주소로 변환하여 컴퓨터가 서로 통신할 수 있도록 한다.
+ 인터넷의 DNS 시스템은 이름과 숫자 간의 매핑을 관리하여 마치 전화번호부와 같은 기능
+ DNS 서버는 이름에 대한 요청을 IP 주소로 변환하여 최종 사용자가 도메인 이름을 웹 브라우저에 입력할 때 해당 사용자를 어떤 서버에 연결할 것인지를 제어한다. 이 요청을 쿼리라고 한다.

## 로드 밸런싱
+ 분산식 웹 서비스로 여러 서버에 부하(Load)를 나누어 줌
+ Round Robin, Least Connection, Response Time, Hash 등의 기법이 있음
+ Round Robin
  + 각 서버에 session을 순서대로 연결하는 방식, 모든 클라이언트를 똑같이 취급 하고, 서버별 처리량을 기억하고 있어야 함.
+ Least Connection
  + 클라이언트와 서버별 연결된 connection 수를 고려하여 가장 적은 서버에 연결하는 방식

## 프로토콜
+ 컴퓨터 간 데이터 통신을 원할히 하기 위해 규정한 약속
+ 신호 송신의 순서(handshake)나 데이터표현법, 오류 검출법 등을 정한 것

## HTTP, HTTPS 프로토콜
### HTTP
+ 하이퍼텍스트를 전송하는 규약
+ 하이퍼텍스트 : 한 문서에서 다른 문서로 즉시 접근할 수 있는 텍스트
+ 비연결성 프로토콜, Request 에 대한 Response 만 전달되고 연결 유지가 안된다.

### 비연결성을 해결하기 위한 방법
+ Cookie/Session : Cookie에 클라이언트에 대한 정보를 저장해뒀다가 사용하거나 Session을 등록해서 유지하는 방식
+ Session Storage/Local Storage : HTML5에서 제공, 세션 스트로지는 세션이 유지되고 있을 때 까지 브라우저 내부 저장소에서 저장하고 세션이 끊기면 자동으로 없어짐, 로컬 스트로지는 사용자나 프론트엔드 내부적으로 삭제 하지 않는 이상 영구적으로 저장됨

### HTTPS
+ HTTP + SSL, HTTP로 통신하는 소켓을 SSL(Secure Sokect Layer) or TLS(Transport Layer Security)라는 프로콜로 대체한 것
+ HTTP 는 TCP 와 직접 통신하지만, HTTPS 에서는 SSL 과 통신하고 SSL 이 TCP 와 통신하는 방식
+ SSL 을 사용하기 때문에 암호화와 증명서, 안전성 보호를 이용할 수 있음
+ 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템 사용
+ 공통키를 공개키 암호화 방식으로 교환하고 이후 통신은 공통키 암호를 사용하는 방식

### HTTP 메서드
+ HEAD : 헤더 정보 취득
+ GET : 리소스 취득
+ POST : 내용 전송 (파일 전송도 가능)
+ PUT : 내용 갱신 위주 (파일 전송도 가능)
+ PATCH : 내용 갱신 위주 (파일 전송도 가능)
+ DELETE : 웹 리소스를 제거 

### PUT PATCH 차이
+ PUT : 리소스의 모든 것을 업데이트 한다. (보내지지 않은 정보에 대해서는 null 값으로 업데이트)
+ PATCH : 리소스의 일부를 업데이트 한다. (보내지지 않은 정보에 대해서는 기존 데이터를 유지하는 방식으로 업데이트)

### HTTP Request - GET, POST 차이점
+ 둘 다 HTTP 프로토콜을 이용해서 서버에 요청 할 때 사용하는 방식
+ GET
  + HTTP Request Message의 Header 부분의 url에 담겨서 전송된다.
  + 쿼리스트링 데이터를 받을 수 있다.
  + 데이터 크기가 제한적이고 보안이 취약하다.
+ POST
  + HTTP Request Message의 Body 부분에 데이터가 담겨서 전송된다.
  + 데이터 크기와 보안이 GET에 비해 낫다.
  + 하지만 아무런 암호화를 거치지 않은 상태로 패킷 가로채기(스니핑, Sniffing)을 당하게 되면 정보를 노출 당할 수 있다.
+ SSL
  + 인터넷 상 데이터를 안전하게 전송하기 위한 인터넷 암호화 통신 프로토콜
  + 데이터 전송을 암호화하면 보안성을 보완할 수 있음, URL 뒤에 붙는 쿼리스트링 내용 모두 암호화되어 전송되기 때문에 보안성을 강화함

### HTTP 상태코드
+ 1xx(정보) : 요청을 받았으며 프로세스를 계속 진행합니다.
+ 2xx(성공) : 요청을 성공적으로 받았으며 인식했고 수용했습니다.
+ 3xx(리다이렉션) : 요청 완료를 위해 추가 작업 조치가 필요합니다.
+ 4xx(클라이언트 오류) : 요청의 문법이 잘못되었거나 요청을 처리할 수 없습니다.
+ 5xx(서버 오류) : 서버가 명백히 유효한 요청에 대한 충족을 실패했습니다.

### SSL
+ 암호화 기반 인터넷 보안 프로토콜
+ 두 통신 장치 사이에 HandShake 인증 프로세스를 시작하여 두 장치의 ID를 확인한다.

### Restful API, 일반적인 HTTP URL
+ 일반적인 HTTP URL : 기능에 중점을 두고 설계, ex) 회원 정보 호출 - '/getUser'
+ Restful API : 자원에 중점을 두고 설계, ex) '/user' 하위에 기능에 대한 구분을 추가, POST, GET, DELETE, PUT 등의 HTTP 메서드를 사용

### Restful API
+ HTTP URL을 통해 자원을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것
+ 최근 서버 프로그램은 다양한 브라우저와 모바일 디바이스에서도 통신하는데 이것을 가능하게 해준다.
+ 장점
  + 멀티플랫폼 지원이 용이합니다.
  + 기존 웹 인프라(HTTP)를 그대로 사용할 수 있습니다.
+ 단점
  + 사용할 수 있는 메소드가 4가지 밖에 없습니다.
  + HTTP 통신 모델에 대해서만 지원합니다.

## 쿠키, 세션
### 쿠키
+ 특정 웹 서버에 접속할 때 생성되는 개인 아이디, 비밀번호 등 방문한 사이트 정보를 담은 임시파일
+ 쿠키는 사용자 브라우저에 저장되기 때문에 서버의 자원을 사용할 수 없다.
+ 보안성이 떨어진다.

### 세션
+ 클라이언트와 웹 서버 간 네트워크 연결이 지속적으로 유지되고 있는 상태
+ 서버에 데이터를 저장해 서버의 자원을 사용할 수 있다.
+ 클라이언트가 페이지를 이동하거나 재접속을 했을 때 구분할 수 있는 수단
+ 쿠키에 비해 보안성이 좋으며 주로 로그인 정보를 유지하는 것에 사용된다.

## 주요 포트 넘버
<table>
  <thead>
    <tr>
      <th>프로토콜</th>
      <th>포트 번호</th>
      <th>내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HTTP</td>
      <td>80</td>
      <td>웹을 지원하기 위한 프로토콜<br>
        GET, PUT 같은 프로토콜 기능을 포함해서 웹 서버에게 어떠한 Content를 요청 또는 웹 서버로 정보를 보냄</td>
    </tr>
    <tr>
      <td>FTP</td>
      <td>20, 21</td>
      <td>TCP를 활용해 대량의 파일을 송신하고 수신하는 프로토콜</td>
    </tr>
    <tr>
      <td>TFTP</td>
      <td>69</td>
      <td>UDP를 사용하는 파일 전송 프로토콜<br>
        라우터나 스위치 등의 네트워크 장비의 IOS 이미지를 업로드, 다운로드할 때 사용</td>
    </tr>
    <tr>
      <td>Telent</td>
      <td>23</td>
      <td>원격지에 있는 장비로 표준 터미널 에뮬레이션 기능을 제공함<br>
        네트워크 장비에서는 텔넷을 통해 원격지에서 장비를 설정</td>
    </tr>
    <tr>
      <td>SMTP</td>
      <td>25</td>
      <td>컴퓨터 네트워크를 통해 전자 메일을 전송하는 프로토콜<br>
        받을 때는 POP3 를 활용</td>
    </tr>
    <tr>
      <td>SNMP</td>
      <td>161</td>
      <td>네트워크 장비를 모니터링하고 제어하기 위해 사용하는 프로토콜<br>
        네트워크 장애 관리, 장비 설정, 통계 성능 및 보안 등을 관리</td>
    </tr>
    <tr>
      <td>DNS</td>
      <td>53</td>
      <td>도메인 주소를 IP ADDRESS 로 변경<br>
        모든 Public IP 주소와 호스트 이름은 DNS에 저장되고 나중에 해당 IP 주소로 변환</td>
    </tr>
  </tbody>
</table>
        
## 프록시
+ 두 PC가 통신을 할 때 직접 하지 않고 중간에서 대리로 통신을 하는 것을 **프록시**라고 하고, 중계 역할을 하는 것을 **프록시 서버**라고 부른다.

### 프록시 서버
![1](https://user-images.githubusercontent.com/48073115/148631177-fb8ee1fd-dc51-4466-9658-616ed9a9844a.png)

+ 클라이언트가 프록시 서버를 통해 다른 네트워크 서비스에 간접적으로 접근을 할 수 있게 하는 것
+ 보안 목적이나 캐싱 등의 기능을 제공한다.
+ 클라이언트는 프록시 서버를 **서버**로 인식하고, 서버 입장에서는 프록시 서버를 **클라이언트**로 인식한다.

#### 포워드 프록시
+ 일반적으로 프록시라고 말하면 포워드 프록시를 말한다.
+ 클라이언트에서 서버로 리소스를 요청할 때 직접 요청하지 않고 프록시 서버를 거쳐서 요청한다.
+ 특징
  + 캐싱
    + 정적 데이터를 저장해두고 동일한 요청의 경우 웹서버 까지 가지 않고 포워드 프록시에서 처리할 수 있는 캐싱 역할을 수행한다.
  + 과부하
    + 웹 서비스에서 요청이 발생할 때 마다 같은 과정을 반복해서 처리하기에 심한 자원 낭비가 생기고, 웹 서버의 부하가 증가할 것이다.
  + IP 우회
    + 서버 측에서는 요청을 받을 때 클라이언트의 IP가 아닌 프록시 서버의 IP를 전달받게 된다.
    + 서버 측에 클라이언트의 정보를 숨길 수 있게 되는 것이다.
  + 제한
    + 보안이 중요한 사내망에서 정해진 사이트에만 연결할 수 있도록 설정하는 등 웹 사용 환경을 제한할 수 있다.

#### 리버스 프록시
+ 포워드 프록시와 반대 개념이다.
+ 클라이언트는 애플리케이션 서버를 직접 호출하는 것이 아니라 프록시 서버를 통해 호출한다.
+ 애플리케이션 서버를 감추는 역할을 한다.
+ ex) Apache Web Server
+ 특징
  + 로드밸런싱
    + 리버스 프록시 뒤에 여러 개의 WAS를 둠으로써, 사용자 요청을 분산할 수 있다.
    + End-point마다 호출 서버를 설정할 수 있어 역할에 따라 서버의 트래픽을 분산할 수도 있다.
  + 보안
    + 보안 상의 이유로 서버에 직접 접근하는 것을 막기 위해 DMZ같은 네트워크에 리버스 프록시를 구성하여 접근하도록 한다.


### 페이지 내용과 데이터의 값이 계속 바뀌면?
+ 캐시 만료기한을 설정함
+ 프록시 서버라도 최초로 받는 요청에는 실제 서버로 요청을 보내야 하므로 그때 만료기한을 설정해서 프록시 서버로 보냄
+ 프록시 서버로 사용자가 요청했을 때 요청한 시각이 프록시에서 다운로드 받은 시간에서 만료기한 이내이면 프록시에서 다운로드 할 것이고, 그렇지 않다면 다시 실제 서버로 요청을 하게 됨

## CORS
+ CORS(Cross Origin Resource Sharing)란 서로 다른 도메인간에 자원을 공유하는 것을 의미하며 기본적으로 차단되어 있습니다.
+ Origin이란 출처를 말하며 Protocol + Host + Port를 합친 것을 의미한다.
+ CORS 에러는 서버에서 응답 헤더에 특정 헤더를 포함하는 방식으로 해결할 수 있습니다.

## JWT
+ Json 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token
+ JWT는 토큰 자체를 정보로 사용하는 방식으로 정보를 안전하게 전달한다.

### Claim
+ 사용자 정보나 데이터 속성 등을 의미한다.

### JWT 구조
+ Header, Payload, Signature의 3부분으로 이루어져 있다.
+ Header
  + typ 와 alg 두 가지 정보로 구성된다.
  + typ : 토큰의 타입을 나타낸다 ex)typ : JWT
  + alg : Signature를 해싱하기 위한 알고리즘을 지정하는 것이다.
+ Payload
  + 토큰에서 사용할 정보의 조각들인 Claim이 담겨있다.
+ Signature
  + 토큰을 인코딩하거나 유효성 검증을 할 때 사용되는 고유한 암호화 코드이다.
  + 인코딩된 Header와 Payload를 더한 뒤 비밀키로 해싱하여 생성합니다.
  + Signature는 서버 측에서 관리하는 비밀키가 유출되지 않는 이상 복호화할 수 없습니다.
  + Signature는 토큰의 위변조 여부를 확인하는데 사용됩니다.

### 장점과 단점
+ 장점
  + Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있습니다.
  + 인증 정보에 대한 별도의 저장소가 필요없습니다.
  + JWT는 토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증됬음을 증명하는 서명 등 필요한 모든 정보를 자체적으로 지니고 있습니다.
  + 클라이언트 인증 정보를 저장하는 세션과 다르게, 서버는 무상태가 됩니다.
  + 확장성이 우수합니다.
  + 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능합니다.
  + OAuth의 경우 Facebook, Google 등 소셜 계정을 이용하여 다른 웹서비스에도 로그인을 할 수 있습니다.
+ 단점
  + 쿠키, 세션과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해집니다.
  + Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없습니다.
  + 토큰을 탈취당하면 대처하기 어렵습니다.
  + 특정 사용자의 접속을 강제로 만료하기 어렵지만, 쿠키, 세션 기반 인증은 서버 쪽에서 쉽게 세션을 삭제할 수 있습니다.

<table>
  <thead>
    <tr>
      <th></th>
      <th width="40%">장점</th>
      <th width="40%">단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Cookie & Session</td>
      <td>Cookie만 사용하는 방식보단 보안 향상</br>
          서버 쪽에서 Session 통제 가능</br>
          네트워크 부하 낮음</td>
      <td>세션 저장소 사용으로 인한 서버 부하</td>
    </tr>
    <tr>
      <td>JWT</td>
      <td>인증을 위한 별도의 저장소가 필요 없음</br>
          별도의 I/O 작업 없는 빠른 인증 처리</br>
          확장성이 우수함</td>
      <td>토큰의 길이가 늘어날수록 네트워크 부하</br>
          특정 토큰을 강제로 만료시키기 어려움</td>
    </tr>
  </tbody>
</table>

## AOT, JIT
+ JIT(Just In Time Compile)
  + 브라우저에서 템플릿 컴파일을 진행하기 때문에 느림
  + JIT 컴파일러를 포함해야 하므로 용량도 큼
+ AOT(Ahead Of Time Compile)
  + 빌드 시 템플릿을 먼저 컴파일을 함
  + 빌드에는 시간이 더 소요되지만 브라우저에서는 컴파일이 실행되지 않기 때문에 상대적으로 빠름
+ 개발 시에는 JIT 방식으로 빠르게 빌드해서 변경사항을 확인하고, 실제 서비스 배포시에는 AOT 방식으로 빌드해서 전체 용량 감소 및 컴파일 시간을 없앰

## Big Endian, Little Endian
+ Endian : 컴퓨터 메모리에서 연속된 바이트를 배열하는 방법

<table>
  <thead>
    <tr>
      <th>Big Endian</th>
      <th>Little Endian</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>최상위 바이트가 앞에 오는 경우<br>
        사람이 읽고 쓰는 방법과 같아서 디버깅이 쉬움 - 수가 커지면 메모리에 저장된 데이터를 오른쪽으로 옮겨야 함</td>
      <td>최하위 바이트가 앞에 오는 경우<br>
        디버깅이 어려움<br>
        수가 커지더라도 오버헤드가 발생하지 않음</td>
    </tr>
  </tbody>
</table>

## 가상DOM
+ 추상화한 DOM
+ 탐색비용과 업데이트 비용을 좀 더 줄일 수 있다.
+ 추상화한 DOM 에서 탐색과 업데이트를 한 후 변경사항만 실제 DOM 에 반영
+ 어떻게 DOM 을 추상화할 것인지, 언제 DOM 에 변경사항을 적용할지에 대한 알고리즘이 핵심

## 방화벽
+ 컴퓨터 네트워크를 무단 액세스로부터 보호하는 데 사용되는 네트워크 보안 시스템
+ 외부로부터 악의적인 액세스를 방지, 외부 사용자에게 제한된 액세스 권한을 부여하기 위해 방화벽을 구축
+ 하드웨어 장치, 소프트웨어 프로그램, 또는 이 둘의 조합으로 구성됨
+ 방화벽을 통해 라우팅되는 모든 메시지는 특정 보안 기준에 따라 검사되며 기준을 충족하는 메시지는 네트워크를 통해 성공적으로 통과하거나 해당 메시지가 차단됨
+ 다른 컴퓨터 소프트웨어와 마찬가지로 설치할 수 있으며, 나중에 필요에 따라 사용자 정의하고 액세스 및 보안 기능을 일부 제어할 수 있음

## 브라우저 주소창에 http://www.naver.com 입력 후 엔터를 눌렀을 때 페이지가 렌더링되는 과정
1. local DNS -> 루트 DNS 서버 -> .com DNS 서버 -> naver.com DNS 서버 순서대로 www.naver.com에 해당하는 IP 주소를 요청하고, 있다면 그 서버에서 바로 주소를 받음
2. TCP 통신을 통해 소켓 개방
3. HTTP 프로토콜로 요청
4. 라우팅 중 프록시 서버를 만나면 웹 캐시에 저장된 정보를 response 받음
5. 프록시 서버를 만나지 못해 www.naver.com를 서빙하는 서버까지 가면 요청에 맞는 데이터를 response로 전송함
6. 브라우저의 loader가 해당 response를 다운로드 할지 말지 결정
7. 브라우저의 웹 엔진이 다운로드한 .html 파일을 파싱해 DOM 트리를 결정
8. .html 파싱중 script 태그를 만나면 파싱을 중단함
9. script 태그에 있는 자원을 다운로드해 처리가 완료되면 다시 파싱함
10. CSS parser 가 .css 파일을 파싱해 스타일 규칙을 DOM 트리에 추가하고 렌더 트리를 만듬
11. 렌더 트리를 기반으로 브라우저의 크기에 따라 각 노드들의 크기를 결정
12. 렌더링 엔진이 배치를 시작(페인팅)




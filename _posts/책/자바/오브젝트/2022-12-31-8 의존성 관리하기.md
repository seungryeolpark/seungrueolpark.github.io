---
title: "8.의존성 관리하기"
categories: book_object
---

[1. 변경과 의존성](#변경과-의존성)  
[2. 유연한 설계](#유연한-설계)

# 변경과 의존성
+ 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.
  + **실행 시점** : 의존하는 객체가 정상적으로 동작하기 위해서는 실행시에 의존 대상 객체가 반드시 존재해야 한다.
  + **구현 시점** : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
+ 어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말한다. 의존성은 방향성을 가지며 항상 단방향이다.
+ 의존성이란 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성이다.

## 의존성 전이
+ **직접 의존성** : 한 요소가 다른 요소에 직접 의존하는 경우
+ **간접 의존성** : 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우

## 런타임 의존성과 컴파일타임 의존성
+ 런타임 의존성과 컴파일타임 의존성이 다를 수 있다. 
+ 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.
+ 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연하고 재사용이 가능해진다.

## 컨텍스트 독립성
+ **컨텍스트 독립적** : 각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다.
+ 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.
+ 설계가 유연해지기 위해서는 가능한 한 자신이 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 한다.

## 의존성 해결
+ **의존성 해결** : 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것
+ 의존성 해결하는 일반적인 방법들
  + 객체를 생성하는 시점에 생성자를 통해 의존성 해결
  + 객체 생성 후 setter 메서드를 통해 의존성 해결
  + 메서드 실행 시 인자를 이용해 의존성 해결

# 유연한 설계
## 의존성과 결합도
+ **의존성** : 두 요소 사이의 관계 유무
+ **결합도** : 두 요소 사이에 존재하는 의존성의 정도
+ 객체지향 패러다임의 근간은 협력이며 객체들이 협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야 한다. 이런 지식들이 객체 사이의 의존성을 낳는다.
+ 의존성은 객체들의 협력을 가능하게 만드는 매게체라는 관점에서 바람직하지만 의존성이 과하면 문제가 될 수 있다.
+ 바람직한 의존성은 재사용성과 관련이 있다.
  + 컨텍스트에 독립적인 의존성은 바람직한 의존성이고 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.
  + 어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 **느슨한 결합도** 또는 **약한 결합도**를 가진다.
  + 어떤 두 요소 사이에 존재하는 의존성이 바람직하지 못할 때 두 요소가 **단단한 결합도** 또는 **강한 결합도**를 가진다.
  + 바람직한 의존성이란 설계를 재사용하기 쉽게 만드는 의존성이고 결합도가 느슨하다고 표현한다.
  + 바람직하지 못한 의존성이란 재사용하기 어렵게 만드는 의존성이고 결합도가 강하다고 표현한다.
+ 결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.
  + 한 요소가 다른 요소에 대해 더 많은 정보를 알고 있을수록 두 요소는 강하게 결합된다.
  + 한 요소가 다른 요소에 대해 더 적은 정보를 알고 있을수록 두 요소는 약하게 결합된다.

## 추상화
+ **추상화** : 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법
  + 추상화를 사용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다. &rarr; 결합도를 느슨하게 유지할 수 있다.
+ 추상화와 결합도의 관점에서 의존 대상을 아래와 같이 구분하는 것이 유용하다. 아래쪽으로 갈수록 클라이언트가 알아야 하는 지식의 양이 적어지기 때문에 결합도가 느슨해진다.
  + 구체 클래스 의존성
  + 추상 클래스 의존성
  + 인터페이스 의존성

## 명시적인 의존성
+ **명시적인 의존성** : 의존성이 명시적으로 퍼블릭 인터페이스에 노출된다.
+ **숨겨진 의존성** : 의존성이 퍼블릭 인터페이스에 표현되지 않는다.
+ 의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수 밖에 없다.
+ 유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다.
+ 명시적인 의존성을 사용해야만 퍼블릭 인터페이스를 통해 컴파일타임 의존성을 적절한 런타임 의존성으로 교체할 수 있다.

## new 는 해롭다
+ new 를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다.
  + new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 한다. &rarr; new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수 밖에 없기 때문에 결합도가 높아진다.
  + new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. &rarr; new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 때문에 결합도가 높아진다.

---
title: "10.상속과 코드 재사용"
categories: book_object
---

[1. 중복 코드](#중복-코드)  
[2. 취약한 기반 클래스 문제](#취약한-기반-클래스-문제)  
[3. 추상화에 의존](#추상화에-의존)  
[4. 차이에 의한 프로그래밍](#차이에-의한-프로그래밍)

## 중복 코드
+ 중복코드를 제거해야하는 가장 큰 이유는 변경을 방해하기 때문이다.
+ 프로그램의 본질은 비즈니스와 관련된 지식을 코드로 변환하는 것이고 이 지식은 항상 변한다.
+ 중복코드가 가지는 가장 큰 문제는 코드를 수정하는데 필요한 노력을 몇 배로 증가시킨다는 것이다.
+ 중복 여부를 판단하는 기준은 변경이다.
    + 요구사항이 변경됐을 때 두 코드를 함깨 수정해야 한다면 이 코드는 중복이다.
    + 중복 여부를 결정하는 기준은 코드의 모양이 아니라 코드가 변경에 반응하는 방식이다.
+ 신뢰할 수 있고 수정하기 쉬운 소프트웨어를 만드는 효과적인 방법 중 하나는 중복을 제거하는 것이다.
+ 중복 코드는 새로운 중복코드를 부른다.
    + 중복 코드를 제거하지 않은 상태에서 코드를 수정할 수 있는 유일한 방법은
  새로운 중복 코드를 추가하는 것 뿐이다.
+ 중복 코드가 늘어날수록 애플리케이션은 변경에 취약해지고 버그가 발생할 가능성이 높아진다.

## 취약한 기반 클래스 문제
+ 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상을 **취약한 기반 클래스 문제**라고 한다.
+ 상속을 사용한다면 피할 수 없는 객체지향 프로그래밍의 근본적인 취약성이다.
+ 상속이라는 문맥 안에서 결합도가 초래하는 문제점이다.
+ 상속 관계를 추가할수록 전체 시스템의 결합도가 높아진다.
    + 상속은 자식 클래스를 점진적으로 추가해서 기능을 확장하는데 용이하지만
  높은 결합도로 안해 부모 클래스를 점진적으로 개선하는 것은 어렵게 만든다.
    + 최악의 경우 모든 자식 클래스를 동시에 수정하고 테스트해야 할 수도 있다.
+ 상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시키고 결합도를 높인다.
이것이 상속이 위험한 동시에 우리가 상속을 피해야 하는 첫 번째 이유다.
+ **객체지향의 기반은 캡슐화를 통한 변경의 통제다. 상속은 코드의 재사용을 위해 캡슐화의 장점을 희석시키고
구현에 대한 결합도를 높임으로써 객체지향이 가진 강력함을 반감시킨다.**
+ **객체지향의 핵심은 객체들의 협력이다. 단순히 코드를 재사용하기 위해
불필요한 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안된다.**
+ **결합도란 다른 대상에 대해 알고 있는 지식의 양이다.**
상속은 기본적으로 부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에
자식 클래스가 부모 클래스의 내부에 대해 속속들이 알도록 강요한다.
    + 코드 재사용을 위한 상속은 부모 클래스와 자식 클래스를 강하게 결합시키기 때문에
  함께 수정해야 하는 상황 역시 빈번하게 발생할 수 밖에 없다.

### 인터페이스 설계
+ 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 만들어야 한다.

### 상속을 위한 경고
+ 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출한 경우
두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.
+ 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
+ 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우
부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
+ 상속은 코드 재사용을 위해 캡슐화를 희생한다. 완벽한 캡슐화를 원한다면 
코드 재사용을 포기하거나 상속 이외의 다른 방법을 사용해야 한다.
+ 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나
자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.

## 추상화에 의존
+ 중복을 제거하기 위해 상속을 도입할 때 따르는 두 가지 원칙
    + **두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라.**
  메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
    + **부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라.**
  부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이
  재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.
+ 상속 계층이 코드를 진화시키는 데 걸림돌이 된다면 추상화를 찾아내고 상속 계층 안의 클래스들이
그 추상화에 의존하도록 코드를 리펙터링하라. 차이점을 메서드로 추출하고 공통적인 부분은 부모 클래스로 이동하라.
+ 객체 생성 로직에 대한 변경을 막기보다는 핵심 로직의 중복을 막아라.
    + 핵심 로직은 한 곳에 모아 놓고 조심스럽게 캡슐화 해야한다.
    + 공통적인 핵심 로직은 최대한 추상화해야 한다.
+ 상속으로 인한 클래스 사이의 결합을 피할 수 있는 방법은 없다.
    + 상속은 어떤 방식으로든 부모 클래스와 자식 클래스를 결합시킨다.
    + 메서드 구현에 대한 결합은 추상 메서드를 추가함으로써 어느 정도 완화할 수 있지만
  인스턴스 변수에 대한 잠재적인 결합을 제거할 수 있는 방법은 없다.
    + 우리가 원하는 것은 행동을 변경하기 위해 인스턴스 변수를 추가하더라도 상속 계층 전체에 걸쳐
  부작용이 퍼지지 않게 막는 것이다.

## 차이에 의한 프로그래밍
+ 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법
+ 상속을 이용하면 이미 존재하는 클래스의 코드를 쉽게 재사용할 수 있기 때문에 애플리케이션의 점진적인 정의가 가능해진다.
+ 차이에 의한 프로그래밍 목표는 중복 코드를 제거하고 코드를 재사용하는 것이다.
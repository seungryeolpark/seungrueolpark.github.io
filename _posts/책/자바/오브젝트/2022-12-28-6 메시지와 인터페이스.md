---
title: "6.메시지와 인터페이스"
categories: book_object
---

[1. 메시지와 인터페이스](#메시지와-인터페이스)  
[2. 퍼블릭 인터페이스 원칙](#퍼블릭-인터페이스-원칙)  
[3. 트레이드오프](#트레이드오프)

# 메시지와 인터페이스
## 메시지
+ 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단
+ 메시지 전송(메시지 패싱) : 한 객체가 다른 객체에게 도움을 요청하는 것
+ 훌륭한 메시지를 얻기 위한 출발점은 책임 주도 설계 원칙을 따르는 것이다.
+ 책임 주도 설계 방법에 따라 메시지가 객체를 결정하게 하라.

## 인터페이스
+ 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다.
  + 최소한의 인터페이스 : 꼭 필요한 오퍼레이션만을 인터페이스에 포함
  + 추상적인 인터페이스 : 어떻게 수행하는지가 아니라 무엇을 하는지 표현
+ 오퍼레이션은 클라이언트의 의도를 표현하는 이름을 가져야 한다.

# 퍼블릭 인터페이스 원칙
## 디미터 법칙
+ 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 원칙
+ this 객체, 메서드의 매개변수, this 속성, this 속성인 컬렉션의 요소, 메서드 내에 생성된 지역객체만 전송하도록 프로그래밍해야 한다.
+ 협력이라는 컨텍스트 안에서 객체보다 메시지를 먼저 결정하면 두 객체 사이의 구조적인 결합도를 낮출 수 있다.
+ 수신할 객체를 알지 못한 상태에서 메시지를 선택하기 때문에 객체의 내부 구조에 대해 고민할 필요가 없어진다.
+ 메시지가 객체를 선택하게 함으로써 의도적으로 디미터 법칙을 위반할 위험을 최소화할 수 있다.

## 묻지말고 시켜라
+ 절차적인 코드가 정보를 얻은 후에 결정한다면 객체지향 코드는 객체에게 그것을 하도록 시키는 것
+ 메시지를 먼저 선택하면 묻지말고 시켜라 스타일에 따라 협력을 구조화하게 된다.
+ 클라이언트의 관점에서 메시지를 선택하기 때문에 필요한 정보를 물을 필요 없이 원하는 것을 표현한 메시지를 전송하면 된다.

## 의도를 드러내는 인터페이스
+ 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다는 것
+ 의도를 드러내는 선택자 : 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴
+ 수행 방법에 관해서는 언급하지 말고 결과와 목적만을 포함하도록 클래스와 오퍼레이션의 이름을 부여하라.
+ 메시지를 먼저 선택하는 것은 메시지를 전송하는 클라이언트의 관점에서 메시지의 이름을 정한다는 것이다.
+ 당연히 그 이름에는 클라이언트가 무엇을 원하는지, 그 의도가 분명하게 드러날 수 밖에 없다.

## 명령 -쿼리 분리 원칙
+ 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침
+ 루틴 : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
  + 프로시저(명령) : 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류
    + 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
  + 함수(쿼리) : 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류
    + 함수는 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
+ 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다.
  + 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
  + 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
  + 명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있다.
+ 퍼블릭 인터페이스를 설계할 때 부수효과를 가지는 대신 값을 반환하지 않는 명령과 부수효과를 가지지 않는 대신 값을 반환하는 쿼리를 분리하기 바란다. 그 결과 코드는 예측이 가능하고 이해하기 쉬우며 디버깅이 용이한 동시에 유지보수가 수월해질 것이다.
+ 참조 투명성 : 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성
  + 명령과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 참조 투명성의 장점을 제한적이나마 누릴 수 있게 된다.
  + 참조 투명성이라는 특성을 잘 활용하면 버그가 적고 디버깅이 용이하며 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다.
  + 참조 투명성을 만족하는 식의 장점
    + 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
    + 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.

# 트레이드오프
+ 설계를 적절하게 트레이드오프 할 수 있는 능력이 숙련자와 초보자를 구분하는 가장 중요한 기준
+ 원칙이 현재 상황에 부적접하다고 판단된다면 과감하게 원칙을 무시하라.
+ 원칙을 아는 것보다 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지 판단할 수 있는 능력을 기르는 것이다.
+ 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만 자료 구조라면 당연히 내부를 노출해야 하므로 다미터 법칙을 적용할 필요가 없다.

## 함수형 프로그래밍
+ 부수효과가 존재하지 않는 수학적인 함수에 기반하는 프로그래밍
+ 함수형 프로그래밍에서는 참조 투명성의 장점을 극대화할 수 있으며 명령형 프로그래밍에 비해 프로그램의 실행 결과를 이해하고 예측하기가 더 쉽다.

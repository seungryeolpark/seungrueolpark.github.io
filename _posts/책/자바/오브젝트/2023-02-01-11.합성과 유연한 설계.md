---
title: "11.합성과 유연한 설계"
categories: book_object
---

[1. 상속과 합성](#상속과-합성)  
[2. 상속으로 인한 조합의 폭팔적인 증가](#상속으로-인한-조합의-폭팔적인-증가)  
[3. 추상 메서드와 훅 메서드](#추상-메서드와-훅-메서드)  



## 상속과 합성
+ 객체지향 시스템에서 기능을 재사용할 수 있는 가장 대표적인 기법은 **클래스 상속**과 **객체 합성**이다.
+ **코드 재사용성**
    + 상속 : 부모 클래스 안에 구현된 코드 자체를 재사용
    + 합성 : 포함되는 객체의 퍼블릭 인터페이스를 재사용
+ **두 객체 사이의 의존성**
    + 상속 : 부모 클래스와 자식 클래스 사이의 의존성은 **컴파일타임**에 해결(정적인 관계)
    + 합성 : 부모 클래스와 자식 클래스 사이의 의존성은 **런타임**에 해결(동적인 관계)
+ 상속 관계는 **is-a** 관계, 합성 관계는 **has-a** 관계라고 부른다.
+ 상속과 합성은 **코드 재사용성**이라는 동일한 목적을 가지지만
구현 방법부터 변경을 다루는 방식에 이르기까지 모든 면에서 도드라진 차이를 보인다.
+ **코드 재사용을 위해서는 객체 합성이 클래스 상속보다 더 좋은 방법이다.**
+ 대부분의 경우 구현에 대한 결합보다 인터페이스에 대한 결합이 더 좋다.

### 객체 합성이 클래스 상속보다 더 좋은 방법이다
+ 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법은 상속이다.
  + 하지만 상속은 코드 재사용을 위한 우아한 해결책은 아니다.
  + 상속은 부모 클래스의 세부적인 구현에 자식 클래스를 강하게 결합시키기 때문에 코드의 진화를 방해한다.
+ 코드를 재사용하면서도 건전한 결합도를 유지할 수 있는 더 좋은 방법은 **합성**을 이용하는 것이다.

## 상속으로 인한 조합의 폭팔적인 증가
+ 상속으로 인해 결합도가 높아지면 코드를 수정하는 데 필요한 작업의 양이 과도하게 늘어나는 경향이 있다.
+ 가장 일반적인 상황은 작은 기능들을 조합해서 더 큰 기능을 수행하는 객체를 만들어야 하는 경우다.
  + 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야한다.
  + 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.
+ 상속의 남용으로 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우
**클래스 폭팔**문제 또는 **조합의 폭팔**문제라고 한다.
  + 클래스 폭팔 문제는 자식 클래스가 부모 클래스의 구현에 강하게 결합되도록 강요하는 상속의 근본적인 한계때문에
  발생하는 문제다.
  + 컴파일타임에 결정된 자식 클래스와 부모 클래스 사이의 관계는 변경될 수 없기 때문에
  자식 클래스와 부모 클래스의 다양한 조합이 필요한 상황에서 유일한 해결 방법은 조합의 수만큼 새로운 클래스를 추가하는 것 뿐이다.
  + 합성은 컴파일타임 관계를 런타임 관계로 변경함으로써 이 문제를 해결한다.

## 추상 메서드와 훅 메서드
+ 개방-폐쇄 원칙을 만족하는 설계를 만들 수 있는 한가지 방법은
부모 클래스에 새로운 추상 메서드를 추가하고 부모 클래스의 다른 메서드 안에서 호출하는 것이다.
  + 자식 클래스는 추상 메서드를 오버라이딩하고 자신만의 로직을 구현해서 부모 클래스에서
  정의한 플로우에 개입할 수 있게 된다.
+ 추상 메서드의 단점은 상속 계층에 속하는 모든 자식 클래스가 추상 메서드를 오버라이딩해야 한다는 것이다.
  + 대부분의 자식 클래스가 추상 메서드를 동일한 방식으로 구현한다면 상속 계층 전반에 걸쳐 중복 코드가 존재하게 될 것이다.
  + 해결 방법은 메서드에 기본 구현을 제공하는 것이다.
+ 이처럼 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만
편의를 위해 기본 구현을 제공하는 메서드를 **훅 메서드**라고 부른다.
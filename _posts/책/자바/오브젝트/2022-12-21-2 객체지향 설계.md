---
title: "2.객체지향 설계"
categories: book_object
---

[1. 객체지향](#객체지향)  
[2. 협력](#협력)  
[3. 트레이드오프](#트레이드오프)  
[4. 상속, 합성](#상속-합성)

# 객체지향
+ 객체지향이란 객체를 지향하는 것이다. 객체지향의 패러다임 중싱에는 객체가 위치한다.
+ 객체지향에서 가장 중요한 것은 애플리케이션 기능을 구현하기 위해 협력에 참여하는 객체들의 상호작용이다.
+ 객체지향 설계 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것이다.
+ 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것이다.

# 협력
+ 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용이다.
+ 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메세지를 전송하는 것 뿐이다.
+ 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라고 부르고 메세지와 메서드는 다른 개념이다.

# 트레이드오프
+ 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다. 대신에 다를수록 코드는 더 유연해지고 확장 가능해진다.
+ 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다. 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장가능성이 낮아진다.
+ 이와 같이 양면성을 가진 설계가 트레이드오프의 산물이다.

## 동적바인딩, 정적바인딩
+ 동적 바인딩 : 메시지와 메서드를 실행 시점에 바인딩하는 것(코드의 의존성과 실행 시점의 의존성이 다르다)
+ 정적 바인딩 : 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것(코드의 의존성과 실행 시점의 의존성이 같다)

## 다형성
+ 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
+ 다형성을 구현하는 방법은 다양하지만 메시지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다.

# 상속, 합성
+ 항상 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하라.
+ 상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이지만 두가지 관점에서 설계에 안좋은 영향을 미친다.
  + 캡슐화를 위반한다. - 상속을 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.(부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다)
  + 설계를 유연하지 못하게 만든다 - 상속은 컴파일 시점에 부모 클래스와 자식 클래스 사이의 관계를 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.
## 상속
+ 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법
+ 상속은 구현 상속과 인터페이스 상속으로 분류할 수 있다.
  + 구현 상속(서브클래싱) : 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것
  + 인터페이스 상속(서브타이핑) : 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것
+ 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다. - 인터페이스를 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높다.

## 합성
+ 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법
+ 코드 재사용을 위해서는 상속보다는 합성을 선호하는 것이 더 좋은 방법이다.
+ 대부분의 설계에서는 상속과 합성을 함께 사용해야 한다.

## TEMPLATE METHOD 패턴
+ 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

## 차이에 의한 프로그래밍
+ 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법

## 업캐스팅
+ 자식 클래스가 부모 클래스를 대신하는 것

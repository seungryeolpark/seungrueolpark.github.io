---
title: "7.객체 분해"
categories: book_object
---

[1. 객체 분해](#객체-분해)  
[2. 프로시저 추상화, 데이터 추상화](#프로시저-추상화-데이터-추상화)  
[3. 정보은닉, 모듈](#정보은닉-모듈)  

# 객체 분해
+ 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력이 급격하게 떨어지는 **인지 과부하** 현상이 온다.
+ 인지 과부하를 방지하는 가장 좋은 방법은 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업인 **추상화**을 한다.
+ 가장 일반적인 추상화 방법은 한 번에 다뤄야 할 문제의 크기를 줄이는 것이다. 큰 문제를 해결 가능한 작은 문제로 나누는 작업을 **분해**라고 부른다.

# 프로시저 추상화, 데이터 추상화
+ 프로그래밍 패러다임은 프로그래밍을 구하기 위해 사용하는 추상화의 종류와 이 추상화를 이용해 소프트웨어를 분해하는 방법 두 가지 요소로 결정된다.
+ 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.
+ 프로시저 추상화, 데이터 추상화는 현대적인 프로그래밍 언어를 특징 짓는 중요한 두 가지 추상화 메커니즘이다.
## 프로시저 추상화
+ 소프트웨어가 무엇을 해야하는지를 추상화한다.
+ 프로시저 추상화를 중심으로 시스템을 분해한다면 **기능 분해, 알고리즘 분해**라고 부른다.
+ 전통적인 기능 분해 방법은 하향식 접근법을 따른다.

### 하향식 접근법
+ 시스템을 구성하는 가장 최상위 기능을 정의하고 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해나가는 방법
+ 먼저 필요한 기능을 생각하고 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별한다.
+ 하향식 접근법의 문제점
  + 시스템은 하나의 메인 함수로 구성돼 있지 않다.
  + 기능 추가나 요구사항 변경으로 인해 메인 함수를 번번하게 수정해야 한다.
  + 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
  + 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
  + 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.
+ 하향식 접근법은 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임이다.
+ 프로그래밍 과정에서 이미 해결된 알고리즘을 문서화하고 서술하는데는 훌륭한 기법이다.

## 데이터 추상화
+ 소프트웨어가 무엇을 알아야 하는지를 추상화한다.
+ 추상 데이터 타입 : 데이터를 중심으로 타입을 추상화하여 시스템을 분해하는 것
+ 객체지향 : 데이터를 중심으로 프로시저를 추상화하여 시스템을 분해하는 것

### 추상 데이터 타입
+ 추상 데이터 타입을 구현하려면 다음과 같은 특성을 위한 프로그래밍 언어의 자원이 필요하다.
  + 타입 정의를 선언할 수 있어야 한다.
  + 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
  + 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
  + 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.
+ 추상 데이터 타입의 기본 의도는 프로그래밍 언어가 제공하는 타입처럼 동작하는 사용자 정의 타입을 추가할 수 있게하는 것이다.

#### 클래스는 추상 데이터 타입인가?
+ 클래스는 상속과 다형성을 지원하는데 비해 추상 데이터 타입은 지원하지 않는다.
+ **객체지향 프로그래밍** : 상속과 다형성을 지원하는 프로그래밍 패러다임
+ **객체기반 프로그래밍** : 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 패러다임
+ 타입 추가라는 변경의 압력이 더 강한 경우 객체지향, 변경의 주된 압력이 오퍼레이션 추가인 경우 추상 데이터 타입이 유용하다.

# 정보은닉, 모듈
## 정보은닉
+ 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 인터페이스 뒤로 감춰야 한다는 것이 핵심이다.
+ 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리이다.

## 모듈
+ 모듈과 기능 분해는 상호 배타적인 관계가 아니다. 시스템을 모듈로 분해한 후에는 각 모듈 내부를 구현하기 위해 기능 분해를 적용할 수 있다.
  + 모듈 분해 : 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막(퍼블릭 인터페이스)을 설치하는 보존의 과정
  + 기능 분해 : 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정
+ 모듈은 두 가지 비밀을 감춰야 한다.
  + 복잡성 : 모듈이 너무 복잡한 경우 이해하고 사용하기가 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다.
  + 변경 가능성 : 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생 시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.
+ 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다.
+ 각 모듈은 외부에 감춰야 하는 비밀과 관령성이 높은 데이터와 함수의 집합이다. 따라서 모듈 내부는 **높은 응집도**를 유지한다.
+ 모듈과 모듈 사이에서는 퍼블릭 인터페이스를 통해서만 통신하기 때문에 **낮은 결합도**를 유지한다.
+ 모듈은 감춰야 할 데이터를 결정하고 이 데이터를 조작하는데 필요한 함수를 결정한다. 데이터를 중심으로 시스템을 분해하는 것이다.

### 모듈의 장점
+ 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
  + 모듈은 데이터 변경으로 인한 파급효과를 제어할 수 있기 때문에 코드를 수정하고 디버깅하기가 더 용이하다.
+ 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
+ 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.
  + 변수와 함수를 모듈 내부에 포함시키기 때문에 다른 모듈에서도 동일한 이름을 사용할 수 있게 된다. 따라서 모듈은 전역 네임스페이스의 오염을 방지하는 동시에 이름 충돌의 위험을 완화한다.

### 모듈의 단점
+ 인스턴스의 개념을 제공하지 않는다.

---
title: "8.유연한 설계"
categories: book_object
---

[1.개방-폐쇄 원칙](#개방-폐쇄-원칙)   
[2.의존성 주입](#의존성-주입)   
[3.의존성 역전 원칙](#의존성-역전-원칙)

# 개방-폐쇄 원칙
+ 소프트웨어 개체는 확장성에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
  + 확장에 대해 열려 있다. 애플리케이션의 요구사항이 변경될 때 이 변경에 맞는 새로운 동작을 추가해서 애플리케이션의 기능을 확장할 수 있다.
  + 수정에 대해 닫혀 있다. 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.
+ 개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다.
  + **런타임 의존성** : 실행 시에 협력에 참여하는 객체들 사이의 관계
  + **컴파일타임 의존성** : 코드에서 드러나는 클래스들 사이의 관계
  + 유연하고 재사용 가능한 설계에서 런타임 의존성과 컴파일타임 의존성은 서로 다른 구조를 가진다.
  
## 추상화
+ **추상화** : 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법
+ 개방-폐쇄 원칙의 핵심은 **추상화에 의존하는 것**이다.
+ 올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.

## 생성 사용 분리
+ 결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다.
+ 유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두가지 책임을 서로 다른 객체로 분리해야 한다.
+ 하나는 객체를 생성하는 것이고 다른 하나는 객체를 사용하는 것이다.

## FACTORY
+ **FACTORY** : 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체

### PURE FACTORICATION 패턴
+ INFORMATION EXPERT 패턴에 따라 책임을 할당한 결과가 바람직하지 않을 경우 대안으로 사용된다.
+ 어떤 객체가 책임을 수행하는 데 필요한 많은 정보를 가졌지만 해당 책임을 할당할 경우 응집도가 낮아지고 결합도가 높아진다면 가공의 객체를 추가해서 책임을 옮기는 것을 고민하라.

# 의존성 주입
+ 사용하는 객체가 아닌 외부의 독립적인 객체가 인스터를 생성한 후 이를 전달해서 의존성을 해결하는 방법
+ 의존성 주입은 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필요한 런타임 의존성을 전달할 수 있도록 만드는 방법
  + **생성자 주입** : 객체를 생성하는 시점에 생성자를 통한 의존성 해결
  + **setter 주입** : 객체 생성 후 setter 메서드를 통한 의존성 해결
  + **메서드 주입** : 메서드 실행 시 인자를 이용한 의존성 해결

## 숨겨진 의존성은 나쁘다
+ **SERVICE LOCATOR** : 의존성을 해결할 객체들을 보관하고 대신 의존성을 해결해준다.
+ SERVICE LOCATOR의 큰 단점은 의존성을 감춘다는 것이다.
+ 숨겨진 의존성이 나쁜 이유
  + 의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 컴파일타임이 아닌 런타임에 가서야 발견된다. &rarr; 숨겨진 의존성이 이해하기 어렵고 디버깅하기 어려운 이유는 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아니라 실행 시점으로 미루기 때문이다.
  + 의존성을 숨기는 코드는 단위 테스트 작성도 어렵다. &rarr; 정적 변수를 사용해 객체들을 관리하기 때문에 각 단위 테스트는 서로 고립돼야 한다는 단위 테스트의 기본 원칙을 위반한다.
  + 의존성을 이해하기 위해 코드의 내부 구현을 이해할 것을 강요한다. &rarr; 숨겨진 의존성은 캡슐화를 위반한다.
  
# 의존성 역전 원칙
+ 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향이 추상 클래스나 인터페이스와 같은 추상화를 따라야 한다.
  + 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
  + 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.
+ **SEPARATED INTERFACE 패턴** : 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 한다.
+ 훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 하고 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있다.
+ 의존성을 관리해야 하는 이유는 **역할, 책임, 협력**의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다. 따라서 **역할, 책임, 협력에 먼저 집중하라.**

